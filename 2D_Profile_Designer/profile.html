<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kynetic Metalworks - 2D Profile Designer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #8b8b8b;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: #57626b;
            color: white;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            min-height: 48px;
        }

        .header-text {
            flex: 1;
            text-align: center;
        }

        .header h1 {
            font-size: 1.5em;
            margin-bottom: 2px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1em;
            opacity: 0.8;
        }

        .top-controls {
            background: #f8f9fa;
            padding: 20px 30px;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            gap: 30px;
            align-items: center;
            flex-wrap: nowrap;
            min-width: 0;
        }

        .profile-info {
            flex: 1 1 auto;
            min-width: 0;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .input-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 0;
        }

        .input-field label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 14px;
        }

        .input-field input {
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .input-field input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.2);
        }

        .side-indicator {
            display: flex;
            align-items: center;
            margin-right: 20px;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            color: #2c3e50;
            cursor: pointer;
        }

        .side-toggle {
            position: relative;
            width: 80px;
            height: 32px;
            background: #e9ecef;
            border-radius: 16px;
            overflow: hidden;
            border: 2px solid #ddd;
        }

        .side-toggle input[type="checkbox"] {
            display: none;
        }

        .toggle-slider {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
        }

        .toggle-slider::before {
            content: '';
            position: absolute;
            width: 50%;
            height: 100%;
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            border-radius: 14px;
            transition: all 0.3s ease;
            transform: translateX(0);
            z-index: 1;
        }

        .side-toggle input:checked + .toggle-slider::before {
            transform: translateX(100%);
            background: linear-gradient(135deg, #3498db, #2980b9);
        }

        .side-label {
            position: absolute;
            width: 50%;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
            z-index: 2;
            transition: all 0.3s ease;
        }

        .side-label.left {
            left: 0;
        }

        .side-label.right {
            right: 0;
        }

        .side-toggle input:not(:checked) + .toggle-slider .side-label.left {
            color: white;
        }

        .side-toggle input:not(:checked) + .toggle-slider .side-label.right {
            color: #666;
        }

        .side-toggle input:checked + .toggle-slider .side-label.left {
            color: #666;
        }

        .side-toggle input:checked + .toggle-slider .side-label.right {
            color: white;
        }

        .mode-controls {
            flex-shrink: 0;
            display: flex;
            gap: 15px;
            align-items: center;
            min-width: 0;
        }

        .mode-toggle {
            display: flex;
            background: #e9ecef;
            border-radius: 8px;
            overflow: hidden;
        }

        .mode-btn {
            padding: 10px 20px;
            border: none;
            background: transparent;
            color: #6c757d;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: #3498db;
            color: white;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #2980b9, #1f6591);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #229954, #1e8449);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #c0392b, #a93226);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }

        .main-content {
            height: calc(100vh - 300px);
            min-height: 500px;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            background: #ffffff;
            overflow: hidden;
        }

        .canvas-container.edit-mode #canvas {
            cursor: default;
        }

        #canvas {
            cursor: crosshair;
            background: 
                radial-gradient(circle, #e8e8e8 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .measurement-label {
            fill: #3498db;
            font-size: 12px;
            font-weight: bold;
            font-family: 'Segoe UI', sans-serif;
            pointer-events: none;
            user-select: none;
            transition: all 0.3s ease;
        }

        .angle-label {
            fill: #e67e22;
            font-size: 12px;
            font-weight: bold;
            font-family: 'Segoe UI', sans-serif;
            pointer-events: none;
            user-select: none;
            transition: all 0.3s ease;
        }

        .edit-mode .measurement-label,
        .edit-mode .angle-label {
            pointer-events: all;
            cursor: pointer;
        }

        .edit-mode .measurement-label:hover {
            fill: #e74c3c;
            font-size: 14px;
        }

        .edit-mode .angle-label:hover {
            fill: #9b59b6;
            font-size: 14px;
        }

        .clickable-bg {
            fill: rgba(255, 255, 255, 0.8);
            stroke: rgba(52, 152, 219, 0.5);
            stroke-width: 1;
            rx: 3;
            ry: 3;
            pointer-events: all;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .edit-mode .clickable-bg {
            opacity: 1;
        }

        .edit-mode .clickable-bg:hover {
            fill: rgba(52, 152, 219, 0.1);
            stroke: rgba(52, 152, 219, 0.8);
            stroke-width: 2;
        }

        .angle-arc {
            stroke: #f39c12;
            stroke-width: 1;
            fill: none;
            stroke-dasharray: 3,3;
            opacity: 0.8;
        }

        .edit-popup {
            position: absolute;
            background: white;
            border: 2px solid #3498db;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 1000;
            min-width: 250px;
            display: none;
        }

        .edit-popup h4 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 16px;
        }

        .edit-popup .input-group {
            margin-bottom: 15px;
        }

        .edit-popup .input-group label {
            display: block;
            margin-bottom: 5px;
            color: #2c3e50;
            font-weight: 600;
        }

        .edit-popup .input-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
        }

        .edit-popup .btn {
            width: 48%;
            margin-right: 4%;
        }

        .edit-popup .btn:last-child {
            margin-right: 0;
        }

        .point {
            fill: #3498db;
            stroke: white;
            stroke-width: 2;
            cursor: pointer;
        }

        .point:hover {
            fill: #2980b9;
            stroke-width: 3;
        }

        .point.draggable {
            cursor: grab;
            stroke-width: 3;
            r: 8;
        }

        .point.dragging {
            cursor: grabbing;
            fill: #e74c3c;
            stroke-width: 4;
        }

        .line {
            stroke: #b0b4b9;
            stroke-width: 3;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .preview-line {
            stroke: #95a5a6;
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 5,5;
        }

        .hem-curve {
            stroke: #ff6b35;
            stroke-width: 3;
            fill: none;
            stroke-linecap: round;
        }

        .hem-parallel {
            stroke: #ff6b35;
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 3,3;
            opacity: 0.8;
        }

        .coating-hash {
            stroke: #e74c3c;
            stroke-width: 1;
            stroke-linecap: round;
            opacity: 0.8;
        }

        .status {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: #2c3e50;
            color: white;
            padding: 10px 20px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
        }

        .coords {
            font-family: monospace;
        }

        @media (max-width: 768px) {
            .top-controls {
                flex-direction: column;
                align-items: stretch;
                flex-wrap: wrap;
            }
            
            .profile-info {
                flex-direction: column;
            }
        }

        /* Line Cross Popup */
        #lineCrossPopup {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #e74c3c;
            border-radius: 10px;
            padding: 24px;
            z-index: 3000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: none;
        }

        #lineCrossPopup h3 {
            color: #e74c3c;
            margin-bottom: 12px;
        }

        #lineCrossPopup .btn {
            width: 100%;
            margin-top: 12px;
        }

        /* New styles for resizable description box */
        .input-field input#profileDescription {
            min-height: 48px;
            height: 48px;
            font-size: 15px;
            padding: 10px 12px;
            resize: vertical;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-text">
                <h1>2D Profile Designer</h1>
                <p>Precision Metal Forming Solutions</p>
            </div>
        </div>
        
        <div class="top-controls">
            <div class="profile-info">
                <div class="input-field">
                    <label for="profileName">Profile Name</label>
                    <input type="text" id="profileName" placeholder="Enter profile name">
                </div>
                <div class="input-field">
                    <label for="profileDescription">Description</label>
                    <input type="text" id="profileDescription" placeholder="Enter description">
                </div>
                <div class="input-field">
                    <label>Total Material Usage</label>
                    <div style="padding: 8px 12px; background: #e9ecef; border-radius: 6px; font-weight: bold; color: #2d5a5c;">
                        <span id="totalLength">0.00"</span>
                    </div>
                </div>
            </div>
            
            <div class="mode-controls">
                <div class="side-indicator" style="flex-direction:column; align-items:flex-start;">
                    <label class="toggle-label" style="margin-bottom:0;">
                        <span>Colored Side:</span>
                        <div class="side-toggle">
                            <input type="checkbox" id="sideToggle" onchange="toggleCoatedSide()">
                            <div class="toggle-slider">
                                <span class="side-label left">A</span>
                                <span class="side-label right">B</span>
                            </div>
                        </div>
                    </label>
                    <div id="hashSideInfo" style="margin-top:8px; padding:6px 14px; background:#f3f6fa; border-radius:6px; font-size:14px; color:#3498db; font-weight:500; text-align:center; box-shadow:0 2px 6px rgba(52,152,219,0.07); width:max-content;">
                        Hash side = Color side
                    </div>
                </div>
                <div class="mode-toggle">
                    <button class="mode-btn active" onclick="setMode('create')" id="createModeBtn">Create</button>
                    <button class="mode-btn" onclick="setMode('edit')" id="editModeBtn">Edit</button>
                </div>

                <button class="btn btn-primary" onclick="downloadProfileImage()">Download Image</button>
                <button class="btn btn-danger" onclick="clearCanvas()">Clear All</button>
            </div>
        </div>
        
        <div class="main-content">
            <div class="canvas-container" id="canvasContainer">
                <svg id="canvas" width="100%" height="100%">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                                refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#4a7c7e" />
                        </marker>
                    </defs>
                    <g id="grid"></g>
                    <g id="lines"></g>
                    <g id="points"></g>
                    <g id="labels"></g>
                </svg>
                
                <!-- Edit Popup -->
                <div id="editPopup" class="edit-popup">
                    <h4 id="popupTitle">Edit Element</h4>
                    <div class="input-group">
                        <label id="popupLabel">Value:</label>
                        <input type="number" id="popupInput" step="0.125" placeholder="Enter value">
                    </div>
                    <div>
                        <button class="btn btn-primary" onclick="applyPopupEdit()">Apply</button>
                        <button class="btn btn-danger" onclick="closeEditPopup()">Cancel</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="status">
            <span id="mode">Click on the canvas to start drawing your profile</span>
            <span class="coords" id="coordinates">Mouse: (0, 0)</span>
        </div>
    </div>

    <script>
async function downloadProfileImage() {
    const container = document.querySelector('.canvas-container');
    
    if (!container) {
        console.error('Canvas container not found');
        return;
    }
    
    try {
        // Load html2canvas if not available
        if (typeof html2canvas === 'undefined') {
            console.log('Loading html2canvas...');
            await loadHtml2Canvas();
        }
        
        console.log('Taking screenshot...');
        const canvas = await html2canvas(container, {
            backgroundColor: 'white',
            scale: 2, // Higher resolution for crisp image
            useCORS: true,
            allowTaint: true,
            logging: false,
            width: container.offsetWidth,
            height: container.offsetHeight,
            scrollX: 0,
            scrollY: 0
        });
        
        // Download the canvas as PNG
        canvas.toBlob((blob) => {
            if (!blob) {
                console.error('Failed to create blob from canvas');
                return;
            }
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.download = 'profile.png';
            a.href = url;
            a.style.display = 'none';
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            setTimeout(() => URL.revokeObjectURL(url), 100);
        }, 'image/png', 1.0);
        
    } catch (error) {
        console.error('Screenshot failed:', error);
        alert('Screenshot failed: ' + error.message);
    }
}

function loadHtml2Canvas() {
    return new Promise((resolve, reject) => {
        if (typeof html2canvas !== 'undefined') {
            resolve();
            return;
        }
        
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
        script.onload = () => {
            console.log('html2canvas loaded successfully');
            resolve();
        };
        script.onerror = () => {
            reject(new Error('Failed to load html2canvas library'));
        };
        document.head.appendChild(script);
    });
}
        let isDrawing = true; // Auto-start drawing
        let isEditMode = false;
        let isDragging = false;
        let dragPointIndex = -1;
        let currentEditElement = null;
        let coatedSideRight = false; // false = left/top coated, true = right/bottom coated
    let points = [];
    // ...existing code...
        let scale = 20; // pixels per inch
        let offset = { x: 50, y: 50 };

        const canvas = document.getElementById('canvas');
        const pointsGroup = document.getElementById('points');
        const linesGroup = document.getElementById('lines');
        const labelsGroup = document.getElementById('labels');

        function closeEditPopup() {
            const popup = document.getElementById('editPopup');
            popup.style.display = 'none';
            currentEditElement = null;
        }

        function applyPopupEdit() {
            if (!currentEditElement) return;
            
            const input = document.getElementById('popupInput');
            const newValue = parseFloat(input.value);
            
            if (isNaN(newValue)) {
                alert('Please enter a valid number.');
                return;
            }
            
            if (currentEditElement.type === 'length') {
                applyLengthEditByIndex(currentEditElement.index, newValue);
            } else if (currentEditElement.type === 'angle') {
                applyAngleEditByIndex(currentEditElement.index, newValue);
            }
            
            redrawProfile();
            updateStats();
            closeEditPopup();
        }

        // Canvas event listeners
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Convert to inches
            const inchX = ((x - offset.x) / scale).toFixed(2);
            const inchY = (((canvas.clientHeight - y) - offset.y) / scale).toFixed(2);
            
            document.getElementById('coordinates').textContent = `Mouse: (${inchX}", ${inchY}")`;
            
            // Handle dragging in edit mode
            if (isDragging && dragPointIndex >= 0) {
                // Save old position
                const oldPoint = { ...points[dragPointIndex] };
                points[dragPointIndex] = { ...points[dragPointIndex], x: x, y: y };

                // Check for line crossing after move
                let crossed = false;
                for (let i = 0; i < points.length - 1; i++) {
                    for (let j = 0; j < points.length - 1; j++) {
                        if (Math.abs(i - j) <= 1) continue; // skip adjacent lines
                        const lineA = { start: points[i], end: points[i + 1] };
                        const lineB = { start: points[j], end: points[j + 1] };
                        if (doLinesIntersect(lineA.start, lineA.end, lineB.start, lineB.end)) {
                            crossed = true;
                            break;
                        }
                    }
                    if (crossed) break;
                }
                if (crossed) {
                    points[dragPointIndex] = oldPoint;
                    showLineCrossPopup();
                    redrawProfile();
                    return;
                }

                redrawProfile();
                return;
            }
            
            // Show preview line when drawing
            if (isDrawing && points.length > 0 && !isEditMode) {
                showPreviewLine(x, y);
            }
        }

        function handleMouseDown(e) {
            if (!isEditMode) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if clicking on a point
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                if (distance <= 12) {
                    isDragging = true;
                    dragPointIndex = i;
                    closeEditPopup();
                    
                    const pointElement = document.querySelector(`circle[data-index="${i}"]`);
                    if (pointElement) {
                        pointElement.classList.add('dragging');
                    }
                    break;
                }
            }
        }

        function handleMouseUp(e) {
            if (isDragging) {
                isDragging = false;
                
                const allPoints = document.querySelectorAll('.point');
                allPoints.forEach(point => point.classList.remove('dragging'));
                
                dragPointIndex = -1;
                redrawProfile();
            }
        }

        function handleCanvasClick(e) {
            if (isDragging) return;
            if (isEditMode) return;
            if (!isDrawing) return;
            // Only block clicks on interactive elements (points, labels, popups)
            const ignoreTags = ['circle', 'rect', 'text', 'foreignObject'];
            if (ignoreTags.includes(e.target.tagName)) return;
            // Accept clicks anywhere inside the SVG
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            addPoint(x, y);
        }


        function addPoint(x, y) {
            let snapX = x, snapY = y;
            // Snap to vertical/horizontal if close enough
            if (points.length > 0) {
                const last = points[points.length - 1];
                const dx = x - last.x;
                const dy = y - last.y;
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                // Normalize angle to [0, 360)
                let normAngle = angle;
                if (normAngle < 0) normAngle += 360;
                // Snap thresholds (degrees)
                const threshold = 10;
                // Snap to horizontal (0 or 180)
                if ((Math.abs(normAngle) < threshold) || (Math.abs(normAngle - 180) < threshold)) {
                    snapY = last.y;
                }
                // Snap to vertical (90 or 270)
                else if ((Math.abs(normAngle - 90) < threshold) || (Math.abs(normAngle - 270) < threshold)) {
                    snapX = last.x;
                }
            }
            const point = { x: snapX, y: snapY };
            // Prevent line crossing
            if (points.length > 1) {
                const newLine = { start: points[points.length - 1], end: point };
                for (let i = 0; i < points.length - 2; i++) {
                    const lineA = { start: points[i], end: points[i + 1] };
                    if (doLinesIntersect(lineA.start, lineA.end, newLine.start, newLine.end)) {
                        showLineCrossPopup();
                        return;
                    }
                }
            }
            points.push(point);
            drawPoint(point, points.length - 1);
            if (points.length > 1) {
                drawLine(points[points.length - 2], point, points.length - 2);
                clearPreviewLine(); // Remove preview line and label immediately
                drawMeasurements(); // Draw permanent label
                // Remove preview angle label immediately
                const angleLabel = document.getElementById('preview-angle-label');
                if (angleLabel) angleLabel.remove();
            }
            updateStats();
            clearPreviewLine();
            // Hem detection: if a new angle < 30Â° is created, show the hem popup
            if (points.length > 2) {
                // The new vertex is at points.length - 2 (the previous point)
                const vertexIndex = points.length - 2;
                const angle = calculateVertexAngle(vertexIndex);
                if (angle < 30) {
                    showHemPopup(vertexIndex);
                }
            }
        }

        // Helper function to check if two line segments intersect
        function doLinesIntersect(p1, p2, p3, p4) {
            function ccw(a, b, c) {
                return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);
            }
            return (ccw(p1, p3, p4) !== ccw(p2, p3, p4)) && (ccw(p1, p2, p3) !== ccw(p1, p2, p4));
        }

        // Custom modal for Hem prompt
        function showHemPopup(pointIndex) {
            let modal = document.getElementById('hemPromptModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'hemPromptModal';
                modal.innerHTML = `
                    <div class="hem-modal-content">
                        <div class="hem-modal-title">Create Hem?</div>
                        <div class="hem-modal-body">Do you want to make a hem at this angle?</div>
                        <div class="hem-modal-actions">
                            <button id="hemYesBtn">Yes</button>
                            <button id="hemNoBtn">No</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                // Add CSS if not present
                if (!document.getElementById('hemModalStyle')) {
                    const style = document.createElement('style');
                    style.id = 'hemModalStyle';
                    style.textContent = `
                        #hemPromptModal {
                            position: fixed;
                            top: 0; left: 0; right: 0; bottom: 0;
                            background: rgba(0,0,0,0.3);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            z-index: 9999;
                        }
                        .hem-modal-content {
                            background: #fff;
                            border-radius: 10px;
                            box-shadow: 0 4px 24px rgba(0,0,0,0.18);
                            padding: 32px 28px 20px 28px;
                            min-width: 320px;
                            text-align: center;
                        }
                        .hem-modal-title {
                            font-size: 1.3em;
                            font-weight: bold;
                            margin-bottom: 12px;
                        }
                        .hem-modal-body {
                            margin-bottom: 18px;
                        }
                        .hem-modal-actions {
                            display: flex;
                            gap: 18px;
                            justify-content: center;
                        }
                        .hem-modal-actions button {
                            font-size: 1em;
                            padding: 7px 22px;
                            border-radius: 6px;
                            border: none;
                            background: #57626b;
                            color: #fff;
                            cursor: pointer;
                            transition: background 0.2s;
                        }
                        .hem-modal-actions button:hover {
                            background: #2d3338;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                modal.style.display = 'flex';
            }
            // Button handlers
            document.getElementById('hemYesBtn').onclick = function() {
                modal.style.display = 'none';
                showSimpleHemDetailsModal(pointIndex);
            };
            document.getElementById('hemNoBtn').onclick = function() {
                modal.style.display = 'none';
            };
        }
        // Simple modal for hem details
    function showSimpleHemDetailsModal(pointIndex) {
            let modal = document.getElementById('hemDetailsModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'hemDetailsModal';
                modal.innerHTML = `
                    <div class="hem-modal-content">
                        <div class="hem-modal-title">Hem Details</div>
                        <div class="hem-modal-body">
                            <div style="margin-bottom:12px;">
                                <label>Length of Hem? <input id="hemLengthInput" type="number" min="0" step="0.1" style="width:80px;" /> in</label>
                            </div>
                            <div style="margin-bottom:12px;">
                                <label>Open or Closed Hem? 
                                    <select id="hemTypeSelect">
                                        <option value="closed">Closed</option>
                                        <option value="open">Open</option>
                                    </select>
                                </label>
                            </div>
                            <div id="openAmountRow" style="margin-bottom:12px; display:none;">
                                <label>If open, by how much? <input id="hemOpenAmountInput" type="number" min="0" step="0.1" style="width:80px;" /> in</label>
                            </div>
                        </div>
                        <div class="hem-modal-actions">
                            <button id="hemDetailsOkBtn">OK</button>
                            <button id="hemDetailsCancelBtn">Cancel</button>
                        </div>
                    </div>
                `;
                // Use same modal CSS as yes/no modal
                modal.style.position = 'fixed';
                modal.style.top = '0';
                modal.style.left = '0';
                modal.style.right = '0';
                modal.style.bottom = '0';
                modal.style.background = 'rgba(0,0,0,0.3)';
                modal.style.display = 'flex';
                modal.style.alignItems = 'center';
                modal.style.justifyContent = 'center';
                modal.style.zIndex = '9999';
                document.body.appendChild(modal);
            } else {
                modal.style.display = 'flex';
            }
            // Show/hide open amount row
            const hemTypeSelect = document.getElementById('hemTypeSelect');
            const openAmountRow = document.getElementById('openAmountRow');
            hemTypeSelect.onchange = function() {
                if (hemTypeSelect.value === 'open') {
                    openAmountRow.style.display = '';
                } else {
                    openAmountRow.style.display = 'none';
                }
            };
            document.getElementById('hemDetailsCancelBtn').onclick = function() {
                modal.style.display = 'none';
            };
            document.getElementById('hemDetailsOkBtn').onclick = function() {
                const length = parseFloat(document.getElementById('hemLengthInput').value);
                const type = document.getElementById('hemTypeSelect').value;
                let openAmount = null;
                if (type === 'open') {
                    openAmount = document.getElementById('hemOpenAmountInput').value;
                }
                modal.style.display = 'none';

                // Change the most recent line's length to the specified hem length
                // The most recent line is the last one added: index = points.length - 2
                if (!isNaN(length) && points.length > 1) {
                    applyLengthEditByIndex(points.length - 2, length);
                    // Set hem vertex index so label is only shown when hem is created
                    window.hemVertexIndex = points.length - 2;
                    // Store hem info for display
                    window.hemInfo = {
                        index: points.length - 2,
                        length: length,
                        type: type,
                        openAmount: openAmount
                    };
                    redrawProfile();
                    addHemArcAtVertex(points.length - 2);
                    // Draw info box below hem vertex
                    showHemInfoBox(window.hemInfo);
        // Draw a little info box below the hem vertex with the entered details
        function showHemInfoBox(hemInfo) {
            if (!hemInfo) return;

            const vertex = points[hemInfo.index];
            if (!vertex) return;
            // Remove any previous info box
            const oldBox = document.getElementById('hem-info-box');
            if (oldBox) oldBox.remove();
            // Info text stacked vertically
            const lines = [`Length: ${hemInfo.length} in`, `Type: ${hemInfo.type}`];
            if (hemInfo.type === 'open' && hemInfo.openAmount) {
                lines.push(`Open: ${hemInfo.openAmount} in`);
            }
            const fontSize = 13;
            const padding = 16;
            const lineHeight = fontSize + 5;
            const boxHeight = lines.length * lineHeight + padding;
            const maxLineLength = Math.max(...lines.map(l => l.length));
            const boxWidth = maxLineLength * 8 + padding;

            // Try several candidate positions for the info box
            const candidateOffsets = [
                { x: 0, y: 60 },    // below
                { x: 0, y: -60 },   // above
                { x: 80, y: 0 },    // right
                { x: -80, y: 0 },   // left
                { x: 80, y: 60 },   // bottom-right
                { x: -80, y: 60 },  // bottom-left
                { x: 80, y: -60 },  // top-right
                { x: -80, y: -60 }  // top-left
            ];

            // Get all points and lines bounding boxes
            const elements = [];
            // Points
            points.forEach(pt => {
                elements.push({
                    x: pt.x - 10,
                    y: pt.y - 10,
                    width: 20,
                    height: 20
                });
            });
            // Lines
            for (let i = 0; i < points.length - 1; i++) {
                const x1 = points[i].x, y1 = points[i].y;
                const x2 = points[i+1].x, y2 = points[i+1].y;
                // Bounding box for line
                const minX = Math.min(x1, x2) - 6;
                const minY = Math.min(y1, y2) - 6;
                const maxX = Math.max(x1, x2) + 6;
                const maxY = Math.max(y1, y2) + 6;
                elements.push({
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                });
            }

            // Find a candidate position that does not overlap any element
            let boxX = vertex.x;
            let boxY = vertex.y + 60;
            let found = false;
            for (const offset of candidateOffsets) {
                const testX = vertex.x + offset.x;
                const testY = vertex.y + offset.y;
                const testBox = {
                    x: testX - boxWidth/2,
                    y: testY - boxHeight/2,
                    width: boxWidth,
                    height: boxHeight
                };
                // Check for overlap
                let overlaps = false;
                for (const el of elements) {
                    if (
                        testBox.x < el.x + el.width &&
                        testBox.x + testBox.width > el.x &&
                        testBox.y < el.y + el.height &&
                        testBox.y + testBox.height > el.y
                    ) {
                        overlaps = true;
                        break;
                    }
                }
                if (!overlaps) {
                    boxX = testX;
                    boxY = testY;
                    found = true;
                    break;
                }
            }
            // If all positions overlap, use below vertex as fallback

            // Create SVG group for the info box
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('id', 'hem-info-box');
            // Box background
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', boxX - boxWidth/2);
            rect.setAttribute('y', boxY - boxHeight/2);
            rect.setAttribute('width', boxWidth);
            rect.setAttribute('height', boxHeight);
            rect.setAttribute('rx', 8);
            rect.setAttribute('fill', '#fffbe6');
            rect.setAttribute('stroke', '#ff6b35');
            rect.setAttribute('stroke-width', '2');
            group.appendChild(rect);
            // Draw each line of text
            lines.forEach((line, idx) => {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', boxX);
                text.setAttribute('y', boxY - boxHeight/2 + padding/2 + lineHeight/2 + idx * lineHeight);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', fontSize);
                text.setAttribute('fill', '#ff6b35');
                text.textContent = line;
                group.appendChild(text);
            });
            // Add to linesGroup so it appears with the lines
            linesGroup.appendChild(group);
        }



        // Draw an orange arc at the specified vertex (between its neighbors)
        function addHemArcAtVertex(vertexIndex) {
            // Only draw if vertex has both previous and next points
            if (vertexIndex <= 0 || vertexIndex >= points.length - 1) return;
            const prev = points[vertexIndex - 1];
            const center = points[vertexIndex];
            const next = points[vertexIndex + 1];
            if (!prev || !center || !next) return;
            const r = 24; // arc radius in px
            // Calculate directions
            const v1 = { x: prev.x - center.x, y: prev.y - center.y };
            const v2 = { x: next.x - center.x, y: next.y - center.y };
            // Normalize
            const len1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
            const len2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
            if (len1 === 0 || len2 === 0) return;
            const n1 = { x: v1.x / len1, y: v1.y / len1 };
            const n2 = { x: v2.x / len2, y: v2.y / len2 };
            // Start/end points for arc
            const startX = center.x + n1.x * r;
            const startY = center.y + n1.y * r;
            const endX = center.x + n2.x * r;
            const endY = center.y + n2.y * r;
            // Calculate angle between vectors
            let angle1 = Math.atan2(n1.y, n1.x);
            let angle2 = Math.atan2(n2.y, n2.x);
            let angleDiff = angle2 - angle1;
            if (angleDiff <= 0) angleDiff += 2 * Math.PI;
            // Always use large arc flag
            const largeArcFlag = 1;
            // If angleDiff < Math.PI, reverse sweep flag so arc is always >180deg
            const sweepFlag = (angleDiff < Math.PI) ? 0 : 1;
            // SVG arc path
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = `M ${startX} ${startY} A ${r} ${r} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`;
            path.setAttribute('d', d);
            path.setAttribute('stroke', '#ff6b35');
            path.setAttribute('stroke-width', '4');
            path.setAttribute('fill', 'none');
            path.setAttribute('class', 'hem-curve');
            // Add to linesGroup so it appears with the lines
            linesGroup.appendChild(path);
        }
                }

                }

                // Redraw profile to update the SVG
                redrawProfile();

                // Turn the most recent line orange
                // Find the SVG line element for the most recent line
                const lineIndex = points.length - 2;
                const lineEl = document.querySelector(`line[data-index="${lineIndex}"]`);
                if (lineEl) {
                    lineEl.setAttribute('stroke', '#ff6b35');
                }

                // Update the measurement label for the most recent line to orange
                // Find the label by data-type and data-index
                const labelEl = document.querySelector(`text.measurement-label[data-type="length"][data-index="${lineIndex}"]`);
                if (labelEl) {
                    labelEl.setAttribute('fill', '#ff6b35');
                }

                // After hem creation, enter edit mode
                setMode('edit');
            };
        

        function closeHemPopup() {
            const hemPopup = document.getElementById('hemPopup');
            if (hemPopup) hemPopup.style.display = 'none';
        }

        function applyHemPopup(pointIndex) {
            closeHemPopup();
            redrawProfile();
        }

        // Update drawHem to use new parameters
        function drawHem(pointIndex, hemType, hemLength, openAmount) {
            // No Hem drawing logic
        }

        function drawPoint(point, index) {
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', point.x);
            circle.setAttribute('cy', point.y);
            circle.setAttribute('r', isEditMode ? 8 : 6);
            circle.setAttribute('class', isEditMode ? 'point draggable' : 'point');
            circle.setAttribute('data-index', index);
            pointsGroup.appendChild(circle);
        }

        function drawLine(start, end, index) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', start.x);
            line.setAttribute('y1', start.y);
            line.setAttribute('x2', end.x);
            line.setAttribute('y2', end.y);
            line.setAttribute('class', 'line');
            line.setAttribute('data-index', index);
            linesGroup.appendChild(line);
            
            // Add coating hash marks
            drawCoatingHashes(start, end);
        }

        function drawCoatingHashes(start, end) {
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length < 20) return;
            
            const dirX = dx / length;
            const dirY = dy / length;
            
            const perpX = -dirY;
            const perpY = dirX;
            
            const hashOffset = coatedSideRight ? 8 : -8;
            const offsetX = perpX * hashOffset;
            const offsetY = perpY * hashOffset;
            
            const hashSpacing = 15;
            const hashLength = 6;
            const numHashes = Math.floor(length / hashSpacing);
            
            for (let i = 1; i < numHashes; i++) {
                const t = i / numHashes;
                const lineX = start.x + dx * t;
                const lineY = start.y + dy * t;
                
                const hash1X = lineX + offsetX - perpX * hashLength/2;
                const hash1Y = lineY + offsetY - perpY * hashLength/2;
                const hash2X = lineX + offsetX + perpX * hashLength/2;
                const hash2Y = lineY + offsetY + perpY * hashLength/2;
                
                const hash = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hash.setAttribute('x1', hash1X);
                hash.setAttribute('y1', hash1Y);
                hash.setAttribute('x2', hash2X);
                hash.setAttribute('y2', hash2Y);
                hash.setAttribute('class', 'coating-hash');
                linesGroup.appendChild(hash);
            }
        }

        function showPreviewLine(mouseX, mouseY) {
            clearPreviewLine();
            if (points.length === 0) return;
            const lastPoint = points[points.length - 1];
            // Draw preview (phantom) line
            let previewLine = document.getElementById('preview');
            if (!previewLine) {
                previewLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                previewLine.setAttribute('id', 'preview');
                previewLine.setAttribute('class', 'preview-line');
                linesGroup.appendChild(previewLine);
            }
            previewLine.setAttribute('x1', lastPoint.x);
            previewLine.setAttribute('y1', lastPoint.y);
            previewLine.setAttribute('x2', mouseX);
            previewLine.setAttribute('y2', mouseY);

            // Calculate preview length
            const deltaX = (mouseX - lastPoint.x) / scale;
            const deltaY = (lastPoint.y - mouseY) / scale;
            const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            // Move label off the line, above it in white space
            const midX = (lastPoint.x + mouseX) / 2; // 12px left of center
            const midY = (lastPoint.y + mouseY) / 2 - 24; // 24px above the line

            // Add or update preview length label
            let lengthLabel = document.getElementById('preview-length-label');
            if (!lengthLabel) {
                lengthLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                lengthLabel.setAttribute('id', 'preview-length-label');
                lengthLabel.setAttribute('class', 'measurement-label');
                lengthLabel.setAttribute('text-anchor', 'middle');
                lengthLabel.setAttribute('dominant-baseline', 'central');

                linesGroup.appendChild(lengthLabel);
            }
            lengthLabel.setAttribute('x', midX);
            lengthLabel.setAttribute('y', midY);
            lengthLabel.textContent = `${length.toFixed(3)}"`;

            // Calculate preview angle
            if (points.length > 1) {
                const prev = points[points.length - 2];
                const last = points[points.length - 1];
                const mousePt = { x: mouseX, y: mouseY };
                const vec1 = { x: prev.x - last.x, y: prev.y - last.y };
                const vec2 = { x: mousePt.x - last.x, y: mousePt.y - last.y };
                const dot = vec1.x * vec2.x + vec1.y * vec2.y;
                const mag1 = Math.sqrt(vec1.x * vec1.x + vec1.y * vec1.y);
                const mag2 = Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
                let angle = 0;
                if (mag1 > 0 && mag2 > 0) {
                    angle = Math.acos(dot / (mag1 * mag2)) * 180 / Math.PI;
                }
                // Place angle label at the previous vertex, above it
                let angleLabel = document.getElementById('preview-angle-label');
                if (!angleLabel) {
                    angleLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    angleLabel.setAttribute('id', 'preview-angle-label');
                    angleLabel.setAttribute('class', 'angle-label');
                    angleLabel.setAttribute('text-anchor', 'middle');
                    angleLabel.setAttribute('dominant-baseline', 'central');
                    linesGroup.appendChild(angleLabel);
                }
                angleLabel.setAttribute('x', last.x);
                angleLabel.setAttribute('y', last.y - 44); // 44px above vertex
                angleLabel.textContent = `${angle.toFixed(1)}Â°`;
            } else {
                // Remove angle label if not needed
                const angleLabel = document.getElementById('preview-angle-label');
                if (angleLabel) angleLabel.remove();
            }
        }

        function clearPreviewLine() {
            const preview = document.getElementById('preview');
            if (preview) {
                preview.remove();
            }
        }

        function drawMeasurements() {
            labelsGroup.innerHTML = '';
            const lineCount = points.length - 1;
            for (let i = 0; i < lineCount; i++) {
                const current = points[i];
                const next = points[i + 1];
                const deltaX = (next.x - current.x) / scale;
                const deltaY = (current.y - next.y) / scale;
                const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                // Move permanent label off the line, above it in white space
                const midX = (current.x + next.x) / 2;
                const midY = (current.y + next.y) / 2 - 24;
                createClickableLabel(midX, midY, `${length.toFixed(3)}"`, 'measurement-label', 'length', i);
            }
            
            // Draw angle measurements for interior vertices
            for (let i = 1; i < points.length - 1; i++) {
                const current = points[i];
                const prev = points[i - 1];
                const next = points[i + 1];
                let labelText;
                // Only show 'HEM' if hemVertexIndex is set and matches this vertex
                if (typeof window.hemVertexIndex !== 'undefined' && i === window.hemVertexIndex) {
                    labelText = 'HEM';
                    console.log('HEM label set at vertex', i, 'with points.length', points.length, 'hemVertexIndex', window.hemVertexIndex);
                } else {
                    const angle = calculateVertexAngle(i);
                    labelText = `${angle.toFixed(1)}Â°`;
                }
                createClickableLabel(current.x + 25, current.y - 25, labelText, 'angle-label', 'angle', i - 1);
                // Draw arc for angle (optional, keep as before)
                if (labelText !== 'HEM') {
                    const angle = calculateVertexAngle(i);
                    drawAngleArc(prev, current, next, angle);
                }
            }
        }

        function createClickableLabel(x, y, text, className, type, index) {
            // Create background rectangle for better clicking
            const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            const textWidth = text.length * 8;
            bg.setAttribute('x', x - textWidth/2 - 4);
            bg.setAttribute('y', y - 8);
            bg.setAttribute('width', textWidth + 8);
            bg.setAttribute('height', 16);
            bg.setAttribute('class', 'clickable-bg');
            bg.setAttribute('data-type', type);
            bg.setAttribute('data-index', index);
            
            // Create text element
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', x);
            label.setAttribute('y', y);
            label.setAttribute('class', className);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('dominant-baseline', 'central');
            label.setAttribute('data-type', type);
            label.setAttribute('data-index', index);
            label.textContent = text;
            
            // Add click handlers to both elements
            const clickHandler = function(e) {
                if (!isEditMode) return;
                e.stopPropagation();
                e.preventDefault();
                showEditPopup(e, type, index, text);
            };
            
            bg.addEventListener('click', clickHandler);
            label.addEventListener('click', clickHandler);
            
            labelsGroup.appendChild(bg);
            labelsGroup.appendChild(label);
        }

        function showEditPopup(event, type, index, currentValue) {
            const popup = document.getElementById('editPopup');
            const title = document.getElementById('popupTitle');
            const label = document.getElementById('popupLabel');
            const input = document.getElementById('popupInput');
            
            currentEditElement = { type: type, index: index };
            
            if (type === 'length') {
                title.textContent = `Edit Line ${index + 1} Length`;
                label.textContent = 'Length (inches):';
                input.value = parseFloat(currentValue.replace('"', '')).toFixed(3);
            } else {
                title.textContent = `Edit Vertex ${index + 1} Angle`;
                label.textContent = 'Angle (degrees):';
                input.value = parseFloat(currentValue.replace('Â°', '')).toFixed(1);
            }
            
            // Get the position of the clicked element
            const targetElement = event.target;
            const canvasRect = canvas.getBoundingClientRect();
            
            let elementX, elementY;
            
            if (targetElement.tagName === 'text') {
                elementX = parseFloat(targetElement.getAttribute('x'));
                elementY = parseFloat(targetElement.getAttribute('y'));
            } else if (targetElement.tagName === 'rect') {
                const rectX = parseFloat(targetElement.getAttribute('x'));
                const rectY = parseFloat(targetElement.getAttribute('y'));
                const rectWidth = parseFloat(targetElement.getAttribute('width'));
                const rectHeight = parseFloat(targetElement.getAttribute('height'));
                elementX = rectX + rectWidth / 2;
                elementY = rectY + rectHeight / 2;
            }
            
            const pageX = canvasRect.left + elementX;
            const pageY = canvasRect.top + elementY;
            
            popup.style.left = (pageX + 30) + 'px';
            popup.style.top = (pageY - 25) + 'px';
            
            popup.style.display = 'block';
            const popupRect = popup.getBoundingClientRect();
            
            if (popupRect.right > window.innerWidth) {
                popup.style.left = (pageX - popupRect.width - 30) + 'px';
            }
            
            if (popupRect.bottom > window.innerHeight) {
                popup.style.top = (pageY - popupRect.height - 10) + 'px';
            }
            
            if (popupRect.top < 0) {
                popup.style.top = (pageY + 30) + 'px';
            }
            
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
        }

        function drawAngleArc(prevPoint, centerPoint, nextPoint, angle) {
            const vec1 = { x: prevPoint.x - centerPoint.x, y: prevPoint.y - centerPoint.y };
            const vec2 = { x: nextPoint.x - centerPoint.x, y: nextPoint.y - centerPoint.y };
            
            const angle1 = Math.atan2(vec1.y, vec1.x);
            const angle2 = Math.atan2(vec2.y, vec2.x);
            
            let startAngle = angle1;
            let endAngle = angle2;
            
            let angleDiff = endAngle - startAngle;
            if (angleDiff > Math.PI) {
                angleDiff -= 2 * Math.PI;
            } else if (angleDiff < -Math.PI) {
                angleDiff += 2 * Math.PI;
            }
            
            if (Math.abs(angleDiff) > Math.PI) {
                [startAngle, endAngle] = [endAngle, startAngle];
                angleDiff = endAngle - startAngle;
                if (angleDiff > Math.PI) {
                    angleDiff -= 2 * Math.PI;
                } else if (angleDiff < -Math.PI) {
                    angleDiff += 2 * Math.PI;
                }
            }
            
            const radius = 20;
            
            const startX = centerPoint.x + radius * Math.cos(startAngle);
            const startY = centerPoint.y + radius * Math.sin(startAngle);
            const endX = centerPoint.x + radius * Math.cos(endAngle);
            const endY = centerPoint.y + radius * Math.sin(endAngle);
            
            const largeArcFlag = Math.abs(angleDiff) > Math.PI ? 1 : 0;
            const sweepFlag = angleDiff > 0 ? 1 : 0;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const pathData = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`;
            path.setAttribute('d', pathData);
            path.setAttribute('class', 'angle-arc');
            
            labelsGroup.appendChild(path);
        }

        function calculateVertexAngle(vertexIndex) {
            const current = points[vertexIndex];
            const prev = points[vertexIndex - 1];
            const next = points[vertexIndex + 1];
            
            const vec1 = { x: prev.x - current.x, y: prev.y - current.y };
            const vec2 = { x: next.x - current.x, y: next.y - current.y };
            
            const dot = vec1.x * vec2.x + vec1.y * vec2.y;
            const mag1 = Math.sqrt(vec1.x * vec1.x + vec1.y * vec1.y);
            const mag2 = Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
            
            let angle = Math.acos(dot / (mag1 * mag2)) * 180 / Math.PI;
            return angle;
        }

        function toggleCoatedSide() {
            coatedSideRight = document.getElementById('sideToggle').checked;
            redrawProfile();
            
            const sideText = coatedSideRight ? 'Side B Colored' : 'Side A Colored';
            const currentMode = isEditMode ? 'Edit Mode' : 'Create Mode';
            document.getElementById('mode').textContent = `${currentMode} - ${sideText}`;
        }

        function setMode(mode) {
            const createBtn = document.getElementById('createModeBtn');
            const editBtn = document.getElementById('editModeBtn');
            const canvasContainer = document.getElementById('canvasContainer');
            
            if (mode === 'create') {
                isEditMode = false;
                isDrawing = true;
                isDragging = false;
                dragPointIndex = -1;
                
                createBtn.classList.add('active');
                editBtn.classList.remove('active');
                canvasContainer.classList.remove('edit-mode');
                
                const sideText = coatedSideRight ? 'Side B Colored' : 'Side A Colored';
                document.getElementById('mode').textContent = `Create Mode - ${sideText}: Click on canvas to add points`;
                
                closeEditPopup();
                redrawProfile();
                
            } else if (mode === 'edit') {
                if (points.length < 2) {
                    alert('Need at least 2 points to enter edit mode.');
                    setMode('create');
                    return;
                }
                
                isEditMode = true;
                isDrawing = false;
                
                createBtn.classList.remove('active');
                editBtn.classList.add('active');
                canvasContainer.classList.add('edit-mode');
                
                const sideText = coatedSideRight ? 'Side B Colored' : 'Side A Colored';
                document.getElementById('mode').textContent = `Edit Mode - ${sideText}: Click measurements to edit, drag vertices to move`;
                
                redrawProfile();
            }
        }

        function finishProfile() {
            if (points.length < 2) {
                alert('Need at least 2 points to finish the profile.');
                return;
            }
            
            isDrawing = false;
            document.getElementById('mode').textContent = 'Profile finished. Use Edit mode to make changes.';
            // Clear hem vertex index when finishing profile
            window.hemVertexIndex = undefined;
            drawMeasurements();
            updateStats();
            clearPreviewLine();
        }

        function redrawProfile() {
            pointsGroup.innerHTML = '';
            linesGroup.innerHTML = '';
            
            points.forEach((point, index) => {
                drawPoint(point, index);
            });
            
            for (let i = 0; i < points.length - 1; i++) {
                drawLine(points[i], points[i + 1], i);
            }
            
            drawMeasurements();
            updateStats(); // Ensure material usage updates after any change
        }

        function drawHem(pointIndex, hemType) {
            // Remove all Hem logic from drawHem
        }

        function clearCanvas() {
            points = [];
            pointsGroup.innerHTML = '';
            linesGroup.innerHTML = '';
            labelsGroup.innerHTML = '';
            isDrawing = true;
            isEditMode = false;
            isDragging = false;
            dragPointIndex = -1;
            // Clear hem vertex index when starting a new profile
            window.hemVertexIndex = undefined;
            setMode('create');
            
            closeEditPopup();
            
            document.getElementById('profileName').value = '';
            document.getElementById('profileDescription').value = '';
            document.getElementById('mode').textContent = 'Click on the canvas to start drawing your profile';
            updateStats();
            clearPreviewLine();
        }

        function updateStats() {
            let totalLength = 0;
            for (let i = 0; i < points.length - 1; i++) {
                const current = points[i];
                const next = points[i + 1];
                const deltaX = (next.x - current.x) / scale;
                const deltaY = (current.y - next.y) / scale;
                totalLength += Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            }
            
            document.getElementById('totalLength').textContent = `${totalLength.toFixed(3)}"`;
        }

        function applyLengthEditByIndex(lineIndex, newLength) {
            const startPoint = points[lineIndex];
            const endPoint = points[lineIndex + 1];
            
            const deltaX = endPoint.x - startPoint.x;
            const deltaY = endPoint.y - startPoint.y;
            const currentLength = Math.sqrt(deltaX * deltaX + deltaY * deltaY) / scale;
            
            if (currentLength === 0) return;
            
            const ratio = (newLength * scale) / (currentLength * scale);
            const newEndPoint = {
                x: startPoint.x + deltaX * ratio,
                y: startPoint.y + deltaY * ratio
            };
            
            // Temporarily update the point and check for line crossing
            const oldEndPoint = { ...points[lineIndex + 1] };
            points[lineIndex + 1] = { ...endPoint, x: newEndPoint.x, y: newEndPoint.y };
            // Check for line crossing
            for (let i = 0; i < points.length - 2; i++) {
                if (i === lineIndex - 1 || i === lineIndex || i === lineIndex + 1) continue; // skip adjacent lines
                const lineA = { start: points[i], end: points[i + 1] };
                const newLine = { start: points[lineIndex], end: points[lineIndex + 1] };
                if (doLinesIntersect(lineA.start, lineA.end, newLine.start, newLine.end)) {
                    points[lineIndex + 1] = oldEndPoint;
                    showLineCrossPopup();
                    return;
                }
            }
        }

        function applyAngleEditByIndex(vertexIndex, newAngle) {
            const actualVertexIndex = vertexIndex + 1;
            const maxVertices = Math.max(0, points.length - 2);
            if (maxVertices === 0 || actualVertexIndex >= points.length - 1) return;

            const currentPoint = points[actualVertexIndex];
            const prevPoint = points[actualVertexIndex - 1];
            const nextPoint = points[actualVertexIndex + 1];

            const deltaX = nextPoint.x - currentPoint.x;
            const deltaY = nextPoint.y - currentPoint.y;
            const lineLength = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            const prevAngle = Math.atan2(prevPoint.y - currentPoint.y, prevPoint.x - currentPoint.x);
            // Set the angle directly to newAngle (relative to previous segment)
            const newAngleRad = prevAngle + (newAngle * Math.PI / 180);

            // Calculate new coordinates for the next point
            const newX = currentPoint.x + Math.cos(newAngleRad) * lineLength;
            const newY = currentPoint.y + Math.sin(newAngleRad) * lineLength;
            // Temporarily update the point and check for line crossing
            const oldNextPoint = { ...points[actualVertexIndex + 1] };
            points[actualVertexIndex + 1] = { ...points[actualVertexIndex + 1], x: newX, y: newY };
            // Check for line crossing
            for (let i = 0; i < points.length - 2; i++) {
                if (i === actualVertexIndex - 1 || i === actualVertexIndex || i === actualVertexIndex + 1) continue; // skip adjacent lines
                const lineA = { start: points[i], end: points[i + 1] };
                const newLine = { start: points[actualVertexIndex], end: points[actualVertexIndex + 1] };
                if (doLinesIntersect(lineA.start, lineA.end, newLine.start, newLine.end)) {
                    points[actualVertexIndex + 1] = oldNextPoint;
                    showLineCrossPopup();
                    return;
                }
            }
        }

        // Initialize canvas size
        function resizeCanvas() {
            const container = document.querySelector('.canvas-container');
            canvas.setAttribute('width', container.clientWidth);
            canvas.setAttribute('height', container.clientHeight);
        }

        // Close popup when clicking outside
        document.addEventListener('click', function(e) {
            const editPopup = document.getElementById('editPopup');
            
            if (editPopup.style.display === 'block' && !editPopup.contains(e.target)) {
                closeEditPopup();
            }
        });

        // Handle Enter key in popup input
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.getElementById('editPopup').style.display === 'block') {
                applyPopupEdit();
            }
            if (e.key === 'Escape' && document.getElementById('editPopup').style.display === 'block') {
                closeEditPopup();
            }
        });

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function showLineCrossPopup() {
            let popup = document.getElementById('lineCrossPopup');
            if (!popup) {
                popup = document.createElement('div');
                popup.id = 'lineCrossPopup';
                popup.style.position = 'fixed';
                popup.style.left = '50%';
                popup.style.top = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                popup.style.background = 'white';
                popup.style.border = '2px solid #e74c3c';
                popup.style.borderRadius = '10px';
                popup.style.padding = '24px';
                popup.style.zIndex = '3000';
                popup.style.boxShadow = '0 10px 30px rgba(0,0,0,0.3)';
                popup.innerHTML = `
                    <h3 style="color:#e74c3c;margin-bottom:12px;">Invalid Action</h3>
                    <div style="margin-bottom:16px;">Lines cannot cross. Please adjust your profile.</div>
                    <button class="btn btn-danger" onclick="closeLineCrossPopup()">Close</button>
                `;
                document.body.appendChild(popup);
            } else {
                popup.style.display = 'block';
            }
        }

        function closeLineCrossPopup() {
            const popup = document.getElementById('lineCrossPopup');
            if (popup) popup.style.display = 'none';
        }
    </script>
</body>
</html>