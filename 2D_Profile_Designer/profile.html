<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sheet Metal Profile Designer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f4f6f8;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 1200px;
            margin: 40px auto;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            padding: 32px 24px;
        }
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 24px;
        }
        .header h1 {
            font-size: 2em;
            color: #2d5a5c;
            margin: 0;
        }
        .header .desc {
            color: #57626b;
            font-size: 1.1em;
        }
        .controls {
            display: flex;
            gap: 18px;
            margin-bottom: 18px;
            flex-wrap: wrap;
        }
        .controls input, .controls select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1.5px solid #e0e4ea;
            font-size: 1em;
        }
        .controls label {
            font-weight: 600;
            color: #2d5a5c;
            margin-right: 8px;
        }
        .controls .btn {
            background: #3498db;
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 10px 20px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        .controls .btn:hover {
            background: #217dbb;
        }
        .canvas-wrap {
            background: #f8fafc;
            border-radius: 10px;
            box-shadow: 0 2px 12px rgba(52,152,219,0.07);
            padding: 16px;
            position: relative;
        }
        #profile-canvas {
            width: 100%;
            height: 600px;
            background: repeating-linear-gradient(90deg, #e8e8e8 0 1px, transparent 1px 20px), repeating-linear-gradient(0deg, #e8e8e8 0 1px, transparent 1px 20px);
            border-radius: 8px;
            display: block;
        }
        .status {
            margin-top: 18px;
            color: #57626b;
            font-size: 1em;
        }
        @media (max-width: 800px) {
            .container { padding: 12px 4px; }
            #profile-canvas { height: 350px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Sheet Metal Profile Designer</h1>
            <span class="desc">DXF-Standard 2D Profile Tool for Fabrication</span>
        </div>
        <div class="controls">
            <label>Profile Name <input id="profileName" type="text" placeholder="Name"></label>
            <label>Description <input id="profileDesc" type="text" placeholder="Description"></label>
            <label>Material <input id="material" type="text" placeholder="Material"></label>
            <label>Thickness <input id="thickness" type="number" step="0.001" min="0" style="width:80px;"></label>
            <label>Tooling <input id="tooling" type="text" placeholder="Tooling"></label>
            <button class="btn" onclick="exportDXF()">Export DXF</button>
            <button class="btn" onclick="exportMetadata()">Export Metadata</button>
            <button class="btn" onclick="clearProfile()">Clear</button>
        </div>
        <div class="canvas-wrap">
            <svg id="profile-canvas"></svg>
        </div>
        <div class="status" id="status"></div>
    </div>
    <script>
// --- DXF Entity Model ---
const scale = 20; // px per inch
let entities = [];
let bends = [];
let hem = null;
let mode = 'draw';
let selectedIdx = null;
let dragging = false;
let dragStart = null;
let meta = {
    name: '',
    desc: '',
    material: '',
    thickness: '',
    tooling: ''
};
const canvas = document.getElementById('profile-canvas');
canvas.setAttribute('width', canvas.parentElement.offsetWidth);
canvas.setAttribute('height', 600);

// --- Drawing ---
function redraw() {
    while (canvas.firstChild) canvas.removeChild(canvas.firstChild);
    entities.forEach((e, i) => {
        if (e.type === 'LINE') drawLine(e, i);
        if (e.type === 'ARC') drawArc(e, i);
        if (e.type === 'POLYLINE') drawPolyline(e, i);
    });
    drawPoints();
    drawHemInfo();
    updateStatus();
}
function drawLine(e, idx) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', e.x1);
    line.setAttribute('y1', e.y1);
    line.setAttribute('x2', e.x2);
    line.setAttribute('y2', e.y2);
    line.setAttribute('stroke', '#2d5a5c');
    line.setAttribute('stroke-width', 3);
    line.setAttribute('data-idx', idx);
    canvas.appendChild(line);
}
function drawArc(e, idx) {
    const startRad = e.startAngle * Math.PI / 180;
    const endRad = e.endAngle * Math.PI / 180;
    const startX = e.cx + e.r * Math.cos(startRad);
    const startY = e.cy + e.r * Math.sin(startRad);
    const endX = e.cx + e.r * Math.cos(endRad);
    const endY = e.cy + e.r * Math.sin(endRad);
    const largeArcFlag = (Math.abs(e.endAngle - e.startAngle) > 180) ? 1 : 0;
    const sweepFlag = (e.endAngle > e.startAngle) ? 1 : 0;
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', `M ${startX} ${startY} A ${e.r} ${e.r} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`);
    path.setAttribute('stroke', '#ff6b35');
    path.setAttribute('stroke-width', 3);
    path.setAttribute('fill', 'none');
    canvas.appendChild(path);
}
function drawPolyline(e, idx) {
    if (!e.points || e.points.length < 2) return;
    let d = `M ${e.points[0].x} ${e.points[0].y}`;
    for (let i = 1; i < e.points.length; i++) {
        d += ` L ${e.points[i].x} ${e.points[i].y}`;
    }
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', d);
    path.setAttribute('stroke', '#2d5a5c');
    path.setAttribute('stroke-width', 2);
    path.setAttribute('fill', 'none');
    canvas.appendChild(path);
}
function drawPoints() {
    entities.forEach((e, i) => {
        if (e.type === 'LINE') {
            drawPoint(e.x1, e.y1, i);
            drawPoint(e.x2, e.y2, i+1000);
        }
        if (e.type === 'ARC') {
            const startRad = e.startAngle * Math.PI / 180;
            const endRad = e.endAngle * Math.PI / 180;
            drawPoint(e.cx + e.r * Math.cos(startRad), e.cx + e.r * Math.sin(startRad), i+2000);
            drawPoint(e.cx + e.r * Math.cos(endRad), e.cx + e.r * Math.sin(endRad), i+3000);
        }
        if (e.type === 'POLYLINE') {
            e.points.forEach((pt, j) => drawPoint(pt.x, pt.y, i*100+j));
        }
        if (e.type === 'HEM_VERTEX') {
            drawHemVertex(e.x, e.y, i, e);
        }
    });
}
function drawPoint(x, y, idx) {
    const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    c.setAttribute('cx', x);
    c.setAttribute('cy', y);
    c.setAttribute('r', 6);
    c.setAttribute('fill', '#3498db');
    c.setAttribute('stroke', '#fff');
    c.setAttribute('stroke-width', 2);
    c.setAttribute('data-idx', idx);
    canvas.appendChild(c);
}

function drawHemVertex(x, y, idx, hemData) {
    const c = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    c.setAttribute('x', x - 7);
    c.setAttribute('y', y - 7);
    c.setAttribute('width', 14);
    c.setAttribute('height', 14);
    c.setAttribute('rx', 4);
    c.setAttribute('fill', '#ff6b35');
    c.setAttribute('stroke', '#2d5a5c');
    c.setAttribute('stroke-width', 2);
    c.setAttribute('data-idx', idx);
    canvas.appendChild(c);
    // Optionally, add a small label
    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label.setAttribute('x', x);
    label.setAttribute('y', y + 22);
    label.setAttribute('text-anchor', 'middle');
    label.setAttribute('font-size', 12);
    label.setAttribute('fill', '#ff6b35');
    label.textContent = 'HEM';
    canvas.appendChild(label);
}
function drawHemInfo() {
    if (!hem) return;
    // Draw info box below hem vertex
    const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    box.setAttribute('x', hem.x - 60);
    box.setAttribute('y', hem.y + 18);
    box.setAttribute('width', 120);
    box.setAttribute('height', 48);
    box.setAttribute('rx', 8);
    box.setAttribute('fill', '#fffbe6');
    box.setAttribute('stroke', '#ff6b35');
    box.setAttribute('stroke-width', 2);
    canvas.appendChild(box);
    const info = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    info.setAttribute('x', hem.x);
    info.setAttribute('y', hem.y + 42);
    info.setAttribute('text-anchor', 'middle');
    info.setAttribute('font-size', 15);
    info.setAttribute('fill', '#ff6b35');
    info.textContent = `Hem: ${hem.length} in, ${hem.type}${hem.open ? ', Open: ' + hem.open : ''}`;
    canvas.appendChild(info);
}
function updateStatus() {
    let total = 0;
    entities.forEach(e => {
        if (e.type === 'LINE') {
            const dx = (e.x2 - e.x1) / scale;
            const dy = (e.y2 - e.y1) / scale;
            total += Math.sqrt(dx*dx + dy*dy);
        }
        if (e.type === 'ARC') {
            const arcLen = Math.abs(e.endAngle - e.startAngle) * Math.PI / 180 * (e.r / scale);
            total += arcLen;
        }
        if (e.type === 'POLYLINE') {
            for (let i = 0; i < e.points.length - 1; i++) {
                const dx = (e.points[i+1].x - e.points[i].x) / scale;
                const dy = (e.points[i+1].y - e.points[i].y) / scale;
                total += Math.sqrt(dx*dx + dy*dy);
            }
        }
    });
    document.getElementById('status').textContent = `Total Material Usage: ${total.toFixed(3)} in`;
}

// --- UI & Events ---
canvas.addEventListener('click', e => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    if (mode === 'draw') {
        if (entities.length > 0) {
            const last = getLastPoint();
            addLine(last.x, last.y, x, y);
            // Hem detection
            if (entities.length > 1) {
                const bendAngle = getBendAngleAtVertex(entities.length - 2);
                // Trigger hem if bend is sharp (close to 0 or 360)
                if (bendAngle < 30 || bendAngle > 330) showHemModal(entities.length - 2, x, y);
            }
        } else {
            // First point
            entities.push({ type: 'POLYLINE', points: [{ x, y }] });
        }
        redraw();
    }
});
function getLastPoint() {
    if (entities.length === 0) return null;
    const last = entities[entities.length - 1];
    if (last.type === 'LINE') return { x: last.x2, y: last.y2 };
    if (last.type === 'POLYLINE') return last.points[last.points.length - 1];
    return null;
}
function addLine(x1, y1, x2, y2) {
    entities.push({ type: 'LINE', x1, y1, x2, y2 });
}
function showHemModal(idx, x, y) {
    // Simple modal for hem details
    const modal = document.createElement('div');
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.width = '100vw';
    modal.style.height = '100vh';
    modal.style.background = 'rgba(0,0,0,0.3)';
    modal.style.display = 'flex';
    modal.style.alignItems = 'center';
    modal.style.justifyContent = 'center';
    modal.style.zIndex = '9999';
    modal.innerHTML = `
        <div style="background:#fff;border-radius:10px;padding:32px 28px;min-width:320px;text-align:center;box-shadow:0 4px 24px rgba(0,0,0,0.18);">
            <div style="font-size:1.3em;font-weight:bold;margin-bottom:12px;">Hem Details</div>
            <div style="margin-bottom:12px;">
                <label>Length <input id="hemLengthInput" type="number" min="0" step="0.1" style="width:80px;" /></label>
            </div>
            <div style="margin-bottom:12px;">
                <label>Type <select id="hemTypeSelect"><option value="closed">Closed</option><option value="open">Open</option></select></label>
            </div>
            <div id="openAmountRow" style="margin-bottom:12px;display:none;">
                <label>Open Amount <input id="hemOpenAmountInput" type="number" min="0" step="0.1" style="width:80px;" /></label>
            </div>
            <div style="display:flex;gap:18px;justify-content:center;">
                <button id="hemDetailsOkBtn" style="padding:7px 22px;border-radius:6px;border:none;background:#3498db;color:#fff;cursor:pointer;">OK</button>
                <button id="hemDetailsCancelBtn" style="padding:7px 22px;border-radius:6px;border:none;background:#e74c3c;color:#fff;cursor:pointer;">Cancel</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    const hemTypeSelect = modal.querySelector('#hemTypeSelect');
    const openAmountRow = modal.querySelector('#openAmountRow');
    hemTypeSelect.onchange = function() {
        openAmountRow.style.display = hemTypeSelect.value === 'open' ? '' : 'none';
    };
    modal.querySelector('#hemDetailsCancelBtn').onclick = function() {
        document.body.removeChild(modal);
    };
    modal.querySelector('#hemDetailsOkBtn').onclick = function() {
        const length = parseFloat(modal.querySelector('#hemLengthInput').value);
        const type = hemTypeSelect.value;
        let open = null;
        if (type === 'open') open = modal.querySelector('#hemOpenAmountInput').value;
    hem = { x, y, length, type, open };
    // Add special hem vertex entity
    entities.push({ type: 'HEM_VERTEX', x, y, length, hemType: type, open });
    document.body.removeChild(modal);
    redraw();
    };
}
function getBendAngleAtVertex(idx) {
    if (entities.length < 2) return 180;
    const prev = entities[idx];
    const curr = entities[idx+1];
    if (!prev || !curr || prev.type !== 'LINE' || curr.type !== 'LINE') return 180;
    const v1 = { x: prev.x2 - prev.x1, y: prev.y2 - prev.y1 };
    const v2 = { x: curr.x2 - curr.x1, y: curr.y2 - curr.y1 };
    const dot = v1.x * v2.x + v1.y * v2.y;
    const mag1 = Math.sqrt(v1.x*v1.x + v1.y*v1.y);
    const mag2 = Math.sqrt(v2.x*v2.x + v2.y*v2.y);
    if (mag1 === 0 || mag2 === 0) return 180;
    let angle = Math.acos(dot / (mag1 * mag2)) * 180 / Math.PI;
    // Convert to internal bend angle: 180 - included angle
    let bendAngle = 180 - angle;
    if (bendAngle < 0) bendAngle += 360;
    return bendAngle;
}
function clearProfile() {
    entities = [];
    bends = [];
    hem = null;
    redraw();
}
function exportDXF() {
    let dxf = '0\nSECTION\n2\nENTITIES\n';
    entities.forEach(ent => {
        if (ent.type === 'LINE') {
            dxf += '0\nLINE\n8\n0\n10\n' + (ent.x1/scale).toFixed(4) + '\n20\n' + (ent.y1/scale).toFixed(4) + '\n11\n' + (ent.x2/scale).toFixed(4) + '\n21\n' + (ent.y2/scale).toFixed(4) + '\n';
        } else if (ent.type === 'ARC') {
            dxf += '0\nARC\n8\n0\n10\n' + (ent.cx/scale).toFixed(4) + '\n20\n' + (ent.cy/scale).toFixed(4) + '\n40\n' + (ent.r/scale).toFixed(4) + '\n50\n' + ent.startAngle.toFixed(4) + '\n51\n' + ent.endAngle.toFixed(4) + '\n';
        } else if (ent.type === 'POLYLINE') {
            dxf += '0\nLWPOLYLINE\n8\n0\n90\n' + ent.points.length + '\n';
            ent.points.forEach(pt => {
                dxf += '10\n' + (pt.x/scale).toFixed(4) + '\n20\n' + (pt.y/scale).toFixed(4) + '\n';
            });
        } else if (ent.type === 'HEM_VERTEX') {
            // DXF POINT entity, layer HEM
            dxf += '0\nPOINT\n8\nHEM\n10\n' + (ent.x/scale).toFixed(4) + '\n20\n' + (ent.y/scale).toFixed(4) + '\n';
        }
    });
    dxf += '0\nENDSEC\n0\nEOF';
    downloadTextFile(dxf, 'profile.dxf');
}
function exportMetadata() {
    meta.name = document.getElementById('profileName').value;
    meta.desc = document.getElementById('profileDesc').value;
    meta.material = document.getElementById('material').value;
    meta.thickness = document.getElementById('thickness').value;
    meta.tooling = document.getElementById('tooling').value;
    downloadTextFile(JSON.stringify(meta, null, 2), 'profile_metadata.json');
}
function downloadTextFile(text, filename) {
    const blob = new Blob([text], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 100);
}
redraw();
    </script>
</body>
</html>
        console.error('Canvas container not found');
        return;
    }
    
    try {
        // Load html2canvas if not available
        if (typeof html2canvas === 'undefined') {
            console.log('Loading html2canvas...');
            await loadHtml2Canvas();
        }
        
        console.log('Taking screenshot...');
        const canvas = await html2canvas(container, {
            backgroundColor: 'white',
            scale: 2, // Higher resolution for crisp image
            useCORS: true,
            allowTaint: true,
            logging: false,
            width: container.offsetWidth,
            height: container.offsetHeight,
            scrollX: 0,
            scrollY: 0
        });
        
        // Download the canvas as PNG
        canvas.toBlob((blob) => {
            if (!blob) {
                console.error('Failed to create blob from canvas');
                return;
            }
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.download = 'profile.png';
            a.href = url;
            a.style.display = 'none';
            
            document.body.appendChild(a);
            a.click();            
            setTimeout(() => URL.revokeObjectURL(url), 100);
        }, 'image/png', 1.0);
        
    } catch (error) {
        console.error('Screenshot failed:', error);
        alert('Screenshot failed: ' + error.message);
    }
}

function loadHtml2Canvas() {
    return new Promise((resolve, reject) => {
        if (typeof html2canvas !== 'undefined') {
            resolve();
            return;
        }
        
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
        script.onload = () => {
            console.log('html2canvas loaded successfully');
            resolve();
        };
        script.onerror = () => {
            reject(new Error('Failed to load html2canvas library'));
        };
        document.head.appendChild(script);
    });
}
        // DXF-style entity storage
        let isDrawing = true;
        let isEditMode = false;
        let isDragging = false;
        let dragEntityIndex = -1;
        let currentEditElement = null;
        let coatedSideRight = false;
        let entities = []; // DXF-style: {type: 'LINE'|'ARC'|'POLYLINE', ...}
        let metadata = {
            material: '',
            thickness: '',
            bendAllowances: [],
            tooling: '',
            description: ''
        };
        let scale = 20;
        let offset = { x: 50, y: 50 };

        const canvas = document.getElementById('canvas');
        const pointsGroup = document.getElementById('points');
        const linesGroup = document.getElementById('lines');
        const labelsGroup = document.getElementById('labels');

        // DXF entity creation helpers
        function addLine(x1, y1, x2, y2) {
            entities.push({ type: 'LINE', x1, y1, x2, y2 });
            redrawProfile();
        }
        function addArc(cx, cy, r, startAngle, endAngle) {
            entities.push({ type: 'ARC', cx, cy, r, startAngle, endAngle });
            redrawProfile();
        }
        function addPolyline(points) {
            entities.push({ type: 'POLYLINE', points });
            redrawProfile();
        }

        // DXF export (geometry only)
        function exportDXF() {
            let dxf = '0\nSECTION\n2\nENTITIES\n';
            entities.forEach(ent => {
                if (ent.type === 'LINE') {
                    dxf += '0\nLINE\n8\n0\n10\n' + (ent.x1/scale).toFixed(4) + '\n20\n' + (ent.y1/scale).toFixed(4) + '\n11\n' + (ent.x2/scale).toFixed(4) + '\n21\n' + (ent.y2/scale).toFixed(4) + '\n';
                } else if (ent.type === 'ARC') {
                    dxf += '0\nARC\n8\n0\n10\n' + (ent.cx/scale).toFixed(4) + '\n20\n' + (ent.cy/scale).toFixed(4) + '\n40\n' + (ent.r/scale).toFixed(4) + '\n50\n' + ent.startAngle.toFixed(4) + '\n51\n' + ent.endAngle.toFixed(4) + '\n';
                } else if (ent.type === 'POLYLINE') {
                    dxf += '0\nLWPOLYLINE\n8\n0\n90\n' + ent.points.length + '\n';
                    ent.points.forEach(pt => {
                        dxf += '10\n' + (pt.x/scale).toFixed(4) + '\n20\n' + (pt.y/scale).toFixed(4) + '\n';
                    });
                }
            });
            dxf += '0\nENDSEC\n0\nEOF';
            downloadTextFile(dxf, 'profile.dxf');
        }

        // Metadata export (JSON)
        function exportMetadataJSON() {
            metadata.description = document.getElementById('profileDescription').value;
            metadata.material = document.getElementById('profileName').value;
            downloadTextFile(JSON.stringify(metadata, null, 2), 'profile_metadata.json');
        }

        function downloadTextFile(text, filename) {
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 100);
        }

        // Drawing logic for DXF entities
        function redrawProfile() {
            pointsGroup.innerHTML = '';
            linesGroup.innerHTML = '';
            labelsGroup.innerHTML = '';
            entities.forEach((ent, idx) => {
                if (ent.type === 'LINE') {
                    drawLineEntity(ent, idx);
                } else if (ent.type === 'ARC') {
                    drawArcEntity(ent, idx);
                } else if (ent.type === 'POLYLINE') {
                    drawPolylineEntity(ent, idx);
                }
            });
            updateStats();
        }

        function drawLineEntity(ent, idx) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', ent.x1);
            line.setAttribute('y1', ent.y1);
            line.setAttribute('x2', ent.x2);
            line.setAttribute('y2', ent.y2);
            line.setAttribute('class', 'line');
            line.setAttribute('data-index', idx);
            linesGroup.appendChild(line);
            // Draw endpoints as points
            drawPointEntity(ent.x1, ent.y1, idx);
            drawPointEntity(ent.x2, ent.y2, idx+1000);
        }

        function drawArcEntity(ent, idx) {
            const startRad = ent.startAngle * Math.PI / 180;
            const endRad = ent.endAngle * Math.PI / 180;
            const startX = ent.cx + ent.r * Math.cos(startRad);
            const startY = ent.cy + ent.r * Math.sin(startRad);
            const endX = ent.cx + ent.r * Math.cos(endRad);
            const endY = ent.cy + ent.r * Math.sin(endRad);
            const largeArcFlag = (Math.abs(ent.endAngle - ent.startAngle) > 180) ? 1 : 0;
            const sweepFlag = (ent.endAngle > ent.startAngle) ? 1 : 0;
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M ${startX} ${startY} A ${ent.r} ${ent.r} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`);
            path.setAttribute('stroke', '#ff6b35');
            path.setAttribute('stroke-width', '3');
            path.setAttribute('fill', 'none');
            linesGroup.appendChild(path);
            drawPointEntity(startX, startY, idx+2000);
            drawPointEntity(endX, endY, idx+3000);
        }

        function drawPolylineEntity(ent, idx) {
            if (!ent.points || ent.points.length < 2) return;
            for (let i = 0; i < ent.points.length - 1; i++) {
                drawLineEntity({ type: 'LINE', x1: ent.points[i].x, y1: ent.points[i].y, x2: ent.points[i+1].x, y2: ent.points[i+1].y }, idx*100+i);
            }
        }

        function drawPointEntity(x, y, idx) {
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', x);
            circle.setAttribute('cy', y);
            circle.setAttribute('r', isEditMode ? 8 : 6);
            circle.setAttribute('class', isEditMode ? 'point draggable' : 'point');
            circle.setAttribute('data-index', idx);
            pointsGroup.appendChild(circle);
        }

        function updateStats() {
            let totalLength = 0;
            entities.forEach(ent => {
                if (ent.type === 'LINE') {
                    const dx = (ent.x2 - ent.x1) / scale;
                    const dy = (ent.y2 - ent.y1) / scale;
                    totalLength += Math.sqrt(dx * dx + dy * dy);
                } else if (ent.type === 'ARC') {
                    const arcLen = Math.abs(ent.endAngle - ent.startAngle) * Math.PI / 180 * (ent.r / scale);
                    totalLength += arcLen;
                } else if (ent.type === 'POLYLINE') {
                    for (let i = 0; i < ent.points.length - 1; i++) {
                        const dx = (ent.points[i+1].x - ent.points[i].x) / scale;
                        const dy = (ent.points[i+1].y - ent.points[i].y) / scale;
                        totalLength += Math.sqrt(dx * dx + dy * dy);
                    }
                }
            });
            document.getElementById('totalLength').textContent = `${totalLength.toFixed(3)}"`;
        }

        function closeEditPopup() {
            const popup = document.getElementById('editPopup');
            popup.style.display = 'none';
            currentEditElement = null;
        }

        function applyPopupEdit() {
            if (!currentEditElement) return;
            
            const input = document.getElementById('popupInput');
            const newValue = parseFloat(input.value);
            
            if (isNaN(newValue)) {
                alert('Please enter a valid number.');
                return;
            }
            
            if (currentEditElement.type === 'length') {
                applyLengthEditByIndex(currentEditElement.index, newValue);
            } else if (currentEditElement.type === 'angle') {
                applyAngleEditByIndex(currentEditElement.index, newValue);
            }
            
            redrawProfile();
            updateStats();
            closeEditPopup();
        }

        // Canvas event listeners
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Convert to inches
            const inchX = ((x - offset.x) / scale).toFixed(2);
            const inchY = (((canvas.clientHeight - y) - offset.y) / scale).toFixed(2);
            
            document.getElementById('coordinates').textContent = `Mouse: (${inchX}", ${inchY}")`;
            
            // Handle dragging in edit mode
            if (isDragging && dragPointIndex >= 0) {
                // Save old position
                const oldPoint = { ...points[dragPointIndex] };
                points[dragPointIndex] = { ...points[dragPointIndex], x: x, y: y };

                // If dragging the hem's previous vertex, update the hem endpoint to keep length and angle fixed
                if (typeof window.hemVertexIndex !== 'undefined' && dragPointIndex === window.hemVertexIndex) {
                    // Calculate the new endpoint for the hem line
                    const hemInfo = window.hemInfo;
                    if (hemInfo && points.length > hemInfo.index + 1) {
                        // Get the previous vertex (hem base)
                        const base = points[hemInfo.index];
                        // Get the original direction and length
                        const origEnd = points[hemInfo.index + 1];
                        const dx = origEnd.x - oldPoint.x;
                        const dy = origEnd.y - oldPoint.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        // Use the hem length from hemInfo if available
                        const hemLength = hemInfo.length || length;
                        // Calculate the angle
                        const angle = Math.atan2(dy, dx);
                        // Calculate new endpoint
                        const newEnd = {
                            x: base.x + Math.cos(angle) * hemLength * scale,
                            y: base.y + Math.sin(angle) * hemLength * scale
                        };
                        points[hemInfo.index + 1] = newEnd;
                    }
                }

                // Check for line crossing after move
                let crossed = false;
                for (let i = 0; i < points.length - 1; i++) {
                    for (let j = 0; j < points.length - 1; j++) {
                        if (Math.abs(i - j) <= 1) continue; // skip adjacent lines
                        const lineA = { start: points[i], end: points[i + 1] };
                        const lineB = { start: points[j], end: points[j + 1] };
                        if (doLinesIntersect(lineA.start, lineA.end, lineB.start, lineB.end)) {
                            crossed = true;
                            break;
                        }
                    }
                    if (crossed) break;
                }
                if (crossed) {
                    points[dragPointIndex] = oldPoint;
                    showLineCrossPopup();
                    redrawProfile();
                    return;
                }

                redrawProfile();
                return;
            }
            
            // Show preview line when drawing
            if (isDrawing && points.length > 0 && !isEditMode) {
                showPreviewLine(x, y);
            }
        }

        function handleMouseDown(e) {
            if (!isEditMode) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if clicking on a point
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                if (distance <= 12) {
                    isDragging = true;
                    dragPointIndex = i;
                    closeEditPopup();
                    
                    const pointElement = document.querySelector(`circle[data-index="${i}"]`);
                    if (pointElement) {
                        pointElement.classList.add('dragging');
                    }
                    break;
                }
            }
        }

        function handleMouseUp(e) {
            if (isDragging) {
                isDragging = false;
                
                const allPoints = document.querySelectorAll('.point');
                allPoints.forEach(point => point.classList.remove('dragging'));
                
                dragPointIndex = -1;
                redrawProfile();
            }
        }

        function handleCanvasClick(e) {
            if (isDragging) return;
            if (isEditMode) return;
            if (!isDrawing) return;
            // Only block clicks on interactive elements (points, labels, popups)
            const ignoreTags = ['circle', 'rect', 'text', 'foreignObject'];
            if (ignoreTags.includes(e.target.tagName)) return;
            // Accept clicks anywhere inside the SVG
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            addPoint(x, y);
        }


        function addPoint(x, y) {
            let snapX = x, snapY = y;
            // Snap to vertical/horizontal if close enough
            if (points.length > 0) {
                const last = points[points.length - 1];
                const dx = x - last.x;
                const dy = y - last.y;
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                // Normalize angle to [0, 360)
                let normAngle = angle;
                if (normAngle < 0) normAngle += 360;
                // Snap thresholds (degrees)
                const threshold = 10;
                // Snap to horizontal (0 or 180)
                if ((Math.abs(normAngle) < threshold) || (Math.abs(normAngle - 180) < threshold)) {
                    snapY = last.y;
                }
                // Snap to vertical (90 or 270)
                else if ((Math.abs(normAngle - 90) < threshold) || (Math.abs(normAngle - 270) < threshold)) {
                    snapX = last.x;
                }
            }
            const point = { x: snapX, y: snapY };
            // Prevent line crossing
            if (points.length > 1) {
                const newLine = { start: points[points.length - 1], end: point };
                for (let i = 0; i < points.length - 2; i++) {
                    const lineA = { start: points[i], end: points[i + 1] };
                    if (doLinesIntersect(lineA.start, lineA.end, newLine.start, newLine.end)) {
                        showLineCrossPopup();
                        return;
                    }
                }
            }
            points.push(point);
            drawPoint(point, points.length - 1);
            if (points.length > 1) {
                drawLine(points[points.length - 2], point, points.length - 2);
                clearPreviewLine(); // Remove preview line and label immediately
                drawMeasurements(); // Draw permanent label
                // Remove preview angle label immediately
                const angleLabel = document.getElementById('preview-angle-label');
                if (angleLabel) angleLabel.remove();
            }
            updateStats();
            clearPreviewLine();
            // Hem detection: if a new angle < 30Â° is created, show the hem popup
            if (points.length > 2) {
                // The new vertex is at points.length - 2 (the previous point)
                const vertexIndex = points.length - 2;
                const angle = calculateVertexAngle(vertexIndex);
                if (angle < 30) {
                    showHemPopup(vertexIndex);
                }
            }
        }

        // Helper function to check if two line segments intersect
        function doLinesIntersect(p1, p2, p3, p4) {
            function ccw(a, b, c) {
                return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);
            }
            return (ccw(p1, p3, p4) !== ccw(p2, p3, p4)) && (ccw(p1, p2, p3) !== ccw(p1, p2, p4));
        }

        // Custom modal for Hem prompt
        function showHemPopup(pointIndex) {
            let modal = document.getElementById('hemPromptModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'hemPromptModal';
                modal.innerHTML = `
                    <div class="hem-modal-content">
                        <div class="hem-modal-title">Create Hem?</div>
                        <div class="hem-modal-body">Do you want to make a hem at this angle?</div>
                        <div class="hem-modal-actions">
                            <button id="hemYesBtn">Yes</button>
                            <button id="hemNoBtn">No</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                // Add CSS if not present
                if (!document.getElementById('hemModalStyle')) {
                    const style = document.createElement('style');
                    style.id = 'hemModalStyle';
                    style.textContent = `
                        #hemPromptModal {
                            position: fixed;
                            top: 0; left: 0; right: 0; bottom: 0;
                            background: rgba(0,0,0,0.3);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            z-index: 9999;
                        }
                        .hem-modal-content {
                            background: #fff;
                            border-radius: 10px;
                            box-shadow: 0 4px 24px rgba(0,0,0,0.18);
                            padding: 32px 28px 20px 28px;
                            min-width: 320px;
                            text-align: center;
                        }
                        .hem-modal-title {
                            font-size: 1.3em;
                            font-weight: bold;
                            margin-bottom: 12px;
                        }
                        .hem-modal-body {
                            margin-bottom: 18px;
                        }
                        .hem-modal-actions {
                            display: flex;
                            gap: 18px;
                            justify-content: center;
                        }
                        .hem-modal-actions button {
                            font-size: 1em;
                            padding: 7px 22px;
                            border-radius: 6px;
                            border: none;
                            background: #57626b;
                            color: #fff;
                            cursor: pointer;
                            transition: background 0.2s;
                        }
                        .hem-modal-actions button:hover {
                            background: #2d3338;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                modal.style.display = 'flex';
            }
            // Button handlers
            document.getElementById('hemYesBtn').onclick = function() {
                modal.style.display = 'none';
                showSimpleHemDetailsModal(pointIndex);
            };
            document.getElementById('hemNoBtn').onclick = function() {
                modal.style.display = 'none';
            };
        }
        // Simple modal for hem details
    function showSimpleHemDetailsModal(pointIndex) {
            let modal = document.getElementById('hemDetailsModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'hemDetailsModal';
                modal.innerHTML = `
                    <div class="hem-modal-content">
                        <div class="hem-modal-title">Hem Details</div>
                        <div class="hem-modal-body">
                            <div style="margin-bottom:12px;">
                                <label>Length of Hem? <input id="hemLengthInput" type="number" min="0" step="0.1" style="width:80px;" /> in</label>
                            </div>
                            <div style="margin-bottom:12px;">
                                <label>Open or Closed Hem? 
                                    <select id="hemTypeSelect">
                                        <option value="closed">Closed</option>
                                        <option value="open">Open</option>
                                    </select>
                                </label>
                            </div>
                            <div id="openAmountRow" style="margin-bottom:12px; display:none;">
                                <label>If open, by how much? <input id="hemOpenAmountInput" type="number" min="0" step="0.1" style="width:80px;" /> in</label>
                            </div>
                        </div>
                        <div class="hem-modal-actions">
                            <button id="hemDetailsOkBtn">OK</button>
                            <button id="hemDetailsCancelBtn">Cancel</button>
                        </div>
                    </div>
                `;
                // Use same modal CSS as yes/no modal
                modal.style.position = 'fixed';
                modal.style.top = '0';
                modal.style.left = '0';
                modal.style.right = '0';
                modal.style.bottom = '0';
                modal.style.background = 'rgba(0,0,0,0.3)';
                modal.style.display = 'flex';
                modal.style.alignItems = 'center';
                modal.style.justifyContent = 'center';
                modal.style.zIndex = '9999';
                document.body.appendChild(modal);
            } else {
                modal.style.display = 'flex';
            }
            // Show/hide open amount row
            const hemTypeSelect = document.getElementById('hemTypeSelect');
            const openAmountRow = document.getElementById('openAmountRow');
            hemTypeSelect.onchange = function() {
                if (hemTypeSelect.value === 'open') {
                    openAmountRow.style.display = '';
                } else {
                    openAmountRow.style.display = 'none';
                }
            };
            document.getElementById('hemDetailsCancelBtn').onclick = function() {
                modal.style.display = 'none';
            };
            document.getElementById('hemDetailsOkBtn').onclick = function() {
                const length = parseFloat(document.getElementById('hemLengthInput').value);
                const type = document.getElementById('hemTypeSelect').value;
                let openAmount = null;
                if (type === 'open') {
                    openAmount = document.getElementById('hemOpenAmountInput').value;
                }
                modal.style.display = 'none';

                // Change the most recent line's length to the specified hem length
                // The most recent line is the last one added: index = points.length - 2
                if (!isNaN(length) && points.length > 1) {
                    applyLengthEditByIndex(points.length - 2, length);
                    // Set hem vertex index so label is only shown when hem is created
                    window.hemVertexIndex = points.length - 2;
                    // Store hem info for display
                    window.hemInfo = {
                        index: points.length - 2,
                        length: length,
                        type: type,
                        openAmount: openAmount
                    };
                    redrawProfile();
                    addHemArcAtVertex(points.length - 2);
                    // Draw info box below hem vertex
                    showHemInfoBox(window.hemInfo);
        // Draw a little info box below the hem vertex with the entered details
        function showHemInfoBox(hemInfo) {
            if (!hemInfo) return;

            const vertex = points[hemInfo.index];
            if (!vertex) return;
            // Remove any previous info box
            const oldBox = document.getElementById('hem-info-box');
            if (oldBox) oldBox.remove();
            // Info text stacked vertically
            const lines = [`Length: ${hemInfo.length} in`, `Type: ${hemInfo.type}`];
            if (hemInfo.type === 'open' && hemInfo.openAmount) {
                lines.push(`Open: ${hemInfo.openAmount} in`);
            }
            const fontSize = 13;
            const padding = 16;
            const lineHeight = fontSize + 5;
            const boxHeight = lines.length * lineHeight + padding;
            const maxLineLength = Math.max(...lines.map(l => l.length));
            const boxWidth = maxLineLength * 8 + padding;

            // Try several candidate positions for the info box
            const candidateOffsets = [
                { x: 0, y: 60 },    // below
                { x: 0, y: -60 },   // above
                { x: 80, y: 0 },    // right
                { x: -80, y: 0 },   // left
                { x: 80, y: 60 },   // bottom-right
                { x: -80, y: 60 },  // bottom-left
                { x: 80, y: -60 },  // top-right
                { x: -80, y: -60 }  // top-left
            ];

            // Get all points and lines bounding boxes
            const elements = [];
            // Points
            points.forEach(pt => {
                elements.push({
                    x: pt.x - 10,
                    y: pt.y - 10,
                    width: 20,
                    height: 20
                });
            });
            // Lines
            for (let i = 0; i < points.length - 1; i++) {
                const x1 = points[i].x, y1 = points[i].y;
                const x2 = points[i+1].x, y2 = points[i+1].y;
                // Bounding box for line
                const minX = Math.min(x1, x2) - 6;
                const minY = Math.min(y1, y2) - 6;
                const maxX = Math.max(x1, x2) + 6;
                const maxY = Math.max(y1, y2) + 6;
                elements.push({
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                });
            }

            // Find a candidate position that does not overlap any element
            let boxX = vertex.x;
            let boxY = vertex.y + 60;
            let found = false;
            for (const offset of candidateOffsets) {
                const testX = vertex.x + offset.x;
                const testY = vertex.y + offset.y;
                const testBox = {
                    x: testX - boxWidth/2,
                    y: testY - boxHeight/2,
                    width: boxWidth,
                    height: boxHeight
                };
                // Check for overlap
                let overlaps = false;
                for (const el of elements) {
                    if (
                        testBox.x < el.x + el.width &&
                        testBox.x + testBox.width > el.x &&
                        testBox.y < el.y + el.height &&
                        testBox.y + testBox.height > el.y
                    ) {
                        overlaps = true;
                        break;
                    }
                }
                if (!overlaps) {
                    boxX = testX;
                    boxY = testY;
                    found = true;
                    break;
                }
            }
            // If all positions overlap, use below vertex as fallback

            // Create SVG group for the info box
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('id', 'hem-info-box');
            // Box background
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', boxX - boxWidth/2);
            rect.setAttribute('y', boxY - boxHeight/2);
            rect.setAttribute('width', boxWidth);
            rect.setAttribute('height', boxHeight);
            rect.setAttribute('rx', 8);
            rect.setAttribute('fill', '#fffbe6');
            rect.setAttribute('stroke', '#ff6b35');
            rect.setAttribute('stroke-width', '2');
            group.appendChild(rect);
            // Draw each line of text
            lines.forEach((line, idx) => {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', boxX);
                text.setAttribute('y', boxY - boxHeight/2 + padding/2 + lineHeight/2 + idx * lineHeight);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', fontSize);
                text.setAttribute('fill', '#ff6b35');
                text.textContent = line;
                group.appendChild(text);
            });
            // Add edit button in edit mode
            if (isEditMode) {
                const editBtn = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                // Move the button further right (e.g., +20px more)
                editBtn.setAttribute('x', boxX + boxWidth/2 + 2);
                editBtn.setAttribute('y', boxY - boxHeight/2 + 18);
                editBtn.setAttribute('font-size', '15');
                editBtn.setAttribute('fill', '#3498db');
                editBtn.setAttribute('cursor', 'pointer');
                editBtn.setAttribute('text-anchor', 'start');
                editBtn.textContent = '\u270E'; // Pencil icon
                editBtn.setAttribute('id', 'hem-edit-btn');
                editBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    // Overlay the modal, but do NOT remove the hem info box
                    let modal = document.getElementById('hemDetailsModal');
                    if (!modal) {
                        showSimpleHemDetailsModal(hemInfo.index);
                    } else {
                        modal.style.display = 'flex';
                    }
                });
                group.appendChild(editBtn);
            }
            // Add to linesGroup so it appears with the lines
            linesGroup.appendChild(group);
        }



        // Draw an orange arc at the specified vertex (between its neighbors)
        function addHemArcAtVertex(vertexIndex) {
            // Only draw if vertex has both previous and next points
            if (vertexIndex <= 0 || vertexIndex >= points.length - 1) return;
            const prev = points[vertexIndex - 1];
            const center = points[vertexIndex];
            const next = points[vertexIndex + 1];
            if (!prev || !center || !next) return;
            const r = 24; // arc radius in px
            // Calculate directions
            const v1 = { x: prev.x - center.x, y: prev.y - center.y };
            const v2 = { x: next.x - center.x, y: next.y - center.y };
            // Normalize
            const len1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
            const len2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
            if (len1 === 0 || len2 === 0) return;
            const n1 = { x: v1.x / len1, y: v1.y / len1 };
            const n2 = { x: v2.x / len2, y: v2.y / len2 };
            // Start/end points for arc
            const startX = center.x + n1.x * r;
            const startY = center.y + n1.y * r;
            const endX = center.x + n2.x * r;
            const endY = center.y + n2.y * r;
            // Calculate angle between vectors
            let angle1 = Math.atan2(n1.y, n1.x);
            let angle2 = Math.atan2(n2.y, n2.x);
            let angleDiff = angle2 - angle1;
            if (angleDiff <= 0) angleDiff += 2 * Math.PI;
            // Always use large arc flag
            const largeArcFlag = 1;
            // If angleDiff < Math.PI, reverse sweep flag so arc is always >180deg
            const sweepFlag = (angleDiff < Math.PI) ? 0 : 1;
            // SVG arc path
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = `M ${startX} ${startY} A ${r} ${r} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`;
            path.setAttribute('d', d);
            path.setAttribute('stroke', '#ff6b35');
            path.setAttribute('stroke-width', '4');
            path.setAttribute('fill', 'none');
            path.setAttribute('class', 'hem-curve');
            // Add to linesGroup so it appears with the lines
            linesGroup.appendChild(path);
        }
                }

                }

                // Redraw profile to update the SVG
                redrawProfile();

                // Turn the most recent line orange
                // Find the SVG line element for the most recent line
                const lineIndex = points.length - 2;
                const lineEl = document.querySelector(`line[data-index="${lineIndex}"]`);
                if (lineEl) {
                    lineEl.setAttribute('stroke', '#ff6b35');
                }

                // Update the measurement label for the most recent line to orange
                // Find the label by data-type and data-index
                const labelEl = document.querySelector(`text.measurement-label[data-type="length"][data-index="${lineIndex}"]`);
                if (labelEl) {
                    labelEl.setAttribute('fill', '#ff6b35');
                }

                // After hem creation, enter edit mode
                setMode('edit');
            };
        

        function closeHemPopup() {
            const hemPopup = document.getElementById('hemPopup');
            if (hemPopup) hemPopup.style.display = 'none';
        }

        function applyHemPopup(pointIndex) {
            closeHemPopup();
            redrawProfile();
        }

        // Update drawHem to use new parameters
        function drawHem(pointIndex, hemType, hemLength, openAmount) {
            // No Hem drawing logic
        }

        function drawPoint(point, index) {
            // If a Hem was just created, skip drawing the last vertex (dot)
            if (typeof window.hemVertexIndex !== 'undefined' && index === points.length - 1 && window.hemVertexIndex === points.length - 2) {
                return;
            }
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', point.x);
            circle.setAttribute('cy', point.y);
            circle.setAttribute('r', isEditMode ? 8 : 6);
            circle.setAttribute('class', isEditMode ? 'point draggable' : 'point');
            circle.setAttribute('data-index', index);
            pointsGroup.appendChild(circle);
        }

        function drawLine(start, end, index) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', start.x);
            line.setAttribute('y1', start.y);
            line.setAttribute('x2', end.x);
            line.setAttribute('y2', end.y);
            line.setAttribute('class', 'line');
            line.setAttribute('data-index', index);
            linesGroup.appendChild(line);
            
            // Add coating hash marks
            drawCoatingHashes(start, end);
        }

        function drawCoatingHashes(start, end) {
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length < 20) return;
            
            const dirX = dx / length;
            const dirY = dy / length;
            
            const perpX = -dirY;
            const perpY = dirX;
            
            const hashOffset = coatedSideRight ? 8 : -8;
            const offsetX = perpX * hashOffset;
            const offsetY = perpY * hashOffset;
            
            const hashSpacing = 15;
            const hashLength = 6;
            const numHashes = Math.floor(length / hashSpacing);
            
            for (let i = 1; i < numHashes; i++) {
                const t = i / numHashes;
                const lineX = start.x + dx * t;
                const lineY = start.y + dy * t;
                
                const hash1X = lineX + offsetX - perpX * hashLength/2;
                const hash1Y = lineY + offsetY - perpY * hashLength/2;
                const hash2X = lineX + offsetX + perpX * hashLength/2;
                const hash2Y = lineY + offsetY + perpY * hashLength/2;
                
                const hash = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hash.setAttribute('x1', hash1X);
                hash.setAttribute('y1', hash1Y);
                hash.setAttribute('x2', hash2X);
                hash.setAttribute('y2', hash2Y);
                hash.setAttribute('class', 'coating-hash');
                linesGroup.appendChild(hash);
            }
        }

        function showPreviewLine(mouseX, mouseY) {
            clearPreviewLine();
            if (points.length === 0) return;
            const lastPoint = points[points.length - 1];
            // Draw preview (phantom) line
            let previewLine = document.getElementById('preview');
            if (!previewLine) {
                previewLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                previewLine.setAttribute('id', 'preview');
                previewLine.setAttribute('class', 'preview-line');
                linesGroup.appendChild(previewLine);
            }
            previewLine.setAttribute('x1', lastPoint.x);
            previewLine.setAttribute('y1', lastPoint.y);
            previewLine.setAttribute('x2', mouseX);
            previewLine.setAttribute('y2', mouseY);

            // Calculate preview length
            const deltaX = (mouseX - lastPoint.x) / scale;
            const deltaY = (lastPoint.y - mouseY) / scale;
            const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            // Move label off the line, above it in white space
            const midX = (lastPoint.x + mouseX) / 2; // 12px left of center
            const midY = (lastPoint.y + mouseY) / 2 - 24; // 24px above the line

            // Add or update preview length label
            let lengthLabel = document.getElementById('preview-length-label');
            if (!lengthLabel) {
                lengthLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                lengthLabel.setAttribute('id', 'preview-length-label');
                lengthLabel.setAttribute('class', 'measurement-label');
                lengthLabel.setAttribute('text-anchor', 'middle');
                lengthLabel.setAttribute('dominant-baseline', 'central');

                linesGroup.appendChild(lengthLabel);
            }
            lengthLabel.setAttribute('x', midX);
            lengthLabel.setAttribute('y', midY);
            lengthLabel.textContent = `${length.toFixed(3)}"`;

            // Calculate preview angle
            if (points.length > 1) {
                const prev = points[points.length - 2];
                const last = points[points.length - 1];
                const mousePt = { x: mouseX, y: mouseY };
                const vec1 = { x: prev.x - last.x, y: prev.y - last.y };
                const vec2 = { x: mousePt.x - last.x, y: mousePt.y - last.y };
                const dot = vec1.x * vec2.x + vec1.y * vec2.y;
                const mag1 = Math.sqrt(vec1.x * vec1.x + vec1.y * vec1.y);
                const mag2 = Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
                let angle = 0;
                if (mag1 > 0 && mag2 > 0) {
                    angle = Math.acos(dot / (mag1 * mag2)) * 180 / Math.PI;
                }
                // Place angle label at the previous vertex, above it
                let angleLabel = document.getElementById('preview-angle-label');
                if (!angleLabel) {
                    angleLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    angleLabel.setAttribute('id', 'preview-angle-label');
                    angleLabel.setAttribute('class', 'angle-label');
                    angleLabel.setAttribute('text-anchor', 'middle');
                    angleLabel.setAttribute('dominant-baseline', 'central');
                    linesGroup.appendChild(angleLabel);
                }
                angleLabel.setAttribute('x', last.x);
                angleLabel.setAttribute('y', last.y - 44); // 44px above vertex
                angleLabel.textContent = `${angle.toFixed(1)}Â°`;
            } else {
                // Remove angle label if not needed
                const angleLabel = document.getElementById('preview-angle-label');
                if (angleLabel) angleLabel.remove();
            }
        }

        function clearPreviewLine() {
            const preview = document.getElementById('preview');
            if (preview) {
                preview.remove();
            }
        }

        function drawMeasurements() {
            labelsGroup.innerHTML = '';
            const lineCount = points.length - 1;
            for (let i = 0; i < lineCount; i++) {
                // Hide the blue line length label for the last line if it is a Hem
                if (typeof window.hemVertexIndex !== 'undefined' && i === points.length - 2 && window.hemVertexIndex === points.length - 2) {
                    continue;
                }
                const current = points[i];
                const next = points[i + 1];
                const deltaX = (next.x - current.x) / scale;
                const deltaY = (current.y - next.y) / scale;
                const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                // Move permanent label off the line, above it in white space
                const midX = (current.x + next.x) / 2;
                const midY = (current.y + next.y) / 2 - 24;
                createClickableLabel(midX, midY, `${length.toFixed(3)}"`, 'measurement-label', 'length', i);
            }
            
            // Draw angle measurements for interior vertices
            for (let i = 1; i < points.length - 1; i++) {
                const current = points[i];
                const prev = points[i - 1];
                const next = points[i + 1];
                let labelText;
                // Only show 'HEM' if hemVertexIndex is set and matches this vertex
                if (typeof window.hemVertexIndex !== 'undefined' && i === window.hemVertexIndex) {
                    labelText = 'HEM';
                    console.log('HEM label set at vertex', i, 'with points.length', points.length, 'hemVertexIndex', window.hemVertexIndex);
                } else {
                    const angle = calculateVertexAngle(i);
                    labelText = `${angle.toFixed(1)}Â°`;
                }
                createClickableLabel(current.x + 25, current.y - 25, labelText, 'angle-label', 'angle', i - 1);
                // Draw arc for angle (optional, keep as before)
                if (labelText !== 'HEM') {
                    const angle = calculateVertexAngle(i);
                    drawAngleArc(prev, current, next, angle);
                }
            }
        }

        function createClickableLabel(x, y, text, className, type, index) {
            // Create background rectangle for better clicking
            const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            const textWidth = text.length * 8;
            bg.setAttribute('x', x - textWidth/2 - 4);
            bg.setAttribute('y', y - 8);
            bg.setAttribute('width', textWidth + 8);
            bg.setAttribute('height', 16);
            bg.setAttribute('class', 'clickable-bg');
            bg.setAttribute('data-type', type);
            bg.setAttribute('data-index', index);
            
            // Create text element
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', x);
            label.setAttribute('y', y);
            label.setAttribute('class', className);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('dominant-baseline', 'central');
            label.setAttribute('data-type', type);
            label.setAttribute('data-index', index);
            label.textContent = text;
            
            // Prevent editing if label is 'HEM' and type is 'angle'
            if (!(type === 'angle' && text === 'HEM')) {
                const clickHandler = function(e) {
                    if (!isEditMode) return;
                    e.stopPropagation();
                    e.preventDefault();
                    showEditPopup(e, type, index, text);
                };
                bg.addEventListener('click', clickHandler);
                label.addEventListener('click', clickHandler);
            } else {
                // Make non-editable visually
                bg.style.cursor = 'default';
                label.style.cursor = 'default';
                bg.style.pointerEvents = 'none';
                label.style.pointerEvents = 'none';
            }
            labelsGroup.appendChild(bg);
            labelsGroup.appendChild(label);
        }

        function showEditPopup(event, type, index, currentValue) {
            const popup = document.getElementById('editPopup');
            const title = document.getElementById('popupTitle');
            const label = document.getElementById('popupLabel');
            const input = document.getElementById('popupInput');
            
            currentEditElement = { type: type, index: index };
            
            if (type === 'length') {
                title.textContent = `Edit Line ${index + 1} Length`;
                label.textContent = 'Length (inches):';
                input.value = parseFloat(currentValue.replace('"', '')).toFixed(3);
            } else {
                title.textContent = `Edit Vertex ${index + 1} Angle`;
                label.textContent = 'Angle (degrees):';
                input.value = parseFloat(currentValue.replace('Â°', '')).toFixed(1);
            }
            
            // Get the position of the clicked element
            const targetElement = event.target;
            const canvasRect = canvas.getBoundingClientRect();
            
            let elementX, elementY;
            
            if (targetElement.tagName === 'text') {
                elementX = parseFloat(targetElement.getAttribute('x'));
                elementY = parseFloat(targetElement.getAttribute('y'));
            } else if (targetElement.tagName === 'rect') {
                const rectX = parseFloat(targetElement.getAttribute('x'));
                const rectY = parseFloat(targetElement.getAttribute('y'));
                const rectWidth = parseFloat(targetElement.getAttribute('width'));
                const rectHeight = parseFloat(targetElement.getAttribute('height'));
                elementX = rectX + rectWidth / 2;
                elementY = rectY + rectHeight / 2;
            }
            
            const pageX = canvasRect.left + elementX;
            const pageY = canvasRect.top + elementY;
            
            popup.style.left = (pageX + 30) + 'px';
            popup.style.top = (pageY - 25) + 'px';
            
            popup.style.display = 'block';
            const popupRect = popup.getBoundingClientRect();
            
            if (popupRect.right > window.innerWidth) {
                popup.style.left = (pageX - popupRect.width - 30) + 'px';
            }
            
            if (popupRect.bottom > window.innerHeight) {
                popup.style.top = (pageY - popupRect.height - 10) + 'px';
            }
            
            if (popupRect.top < 0) {
                popup.style.top = (pageY + 30) + 'px';
            }
            
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
        }

        function drawAngleArc(prevPoint, centerPoint, nextPoint, angle) {
            const vec1 = { x: prevPoint.x - centerPoint.x, y: prevPoint.y - centerPoint.y };
            const vec2 = { x: nextPoint.x - centerPoint.x, y: nextPoint.y - centerPoint.y };
            
            const angle1 = Math.atan2(vec1.y, vec1.x);
            const angle2 = Math.atan2(vec2.y, vec2.x);
            
            let startAngle = angle1;
            let endAngle = angle2;
            
            let angleDiff = endAngle - startAngle;
            if (angleDiff > Math.PI) {
                angleDiff -= 2 * Math.PI;
            } else if (angleDiff < -Math.PI) {
                angleDiff += 2 * Math.PI;
            }
            
            if (Math.abs(angleDiff) > Math.PI) {
                [startAngle, endAngle] = [endAngle, startAngle];
                angleDiff = endAngle - startAngle;
                if (angleDiff > Math.PI) {
                    angleDiff -= 2 * Math.PI;
                } else if (angleDiff < -Math.PI) {
                    angleDiff += 2 * Math.PI;
                }
            }
            
            const radius = 20;
            
            const startX = centerPoint.x + radius * Math.cos(startAngle);
            const startY = centerPoint.y + radius * Math.sin(startAngle);
            const endX = centerPoint.x + radius * Math.cos(endAngle);
            const endY = centerPoint.y + radius * Math.sin(endAngle);
            
            const largeArcFlag = Math.abs(angleDiff) > Math.PI ? 1 : 0;
            const sweepFlag = angleDiff > 0 ? 1 : 0;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const pathData = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`;
            path.setAttribute('d', pathData);
            path.setAttribute('class', 'angle-arc');
            
            labelsGroup.appendChild(path);
        }

        function calculateVertexAngle(vertexIndex) {
            const current = points[vertexIndex];
            const prev = points[vertexIndex - 1];
            const next = points[vertexIndex + 1];
            
            const vec1 = { x: prev.x - current.x, y: prev.y - current.y };
            const vec2 = { x: next.x - current.x, y: next.y - current.y };
            
            const dot = vec1.x * vec2.x + vec1.y * vec2.y;
            const mag1 = Math.sqrt(vec1.x * vec1.x + vec1.y * vec1.y);
            const mag2 = Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
            
            let angle = Math.acos(dot / (mag1 * mag2)) * 180 / Math.PI;
            return angle;
        }

        function toggleCoatedSide() {
            coatedSideRight = document.getElementById('sideToggle').checked;
            redrawProfile();
            
            const sideText = coatedSideRight ? 'Side B Colored' : 'Side A Colored';
            const currentMode = isEditMode ? 'Edit Mode' : 'Create Mode';
            document.getElementById('mode').textContent = `${currentMode} - ${sideText}`;
        }

        function setMode(mode) {
            const createBtn = document.getElementById('createModeBtn');
            const editBtn = document.getElementById('editModeBtn');
            const canvasContainer = document.getElementById('canvasContainer');
            
            if (mode === 'create') {
                isEditMode = false;
                isDrawing = true;
                isDragging = false;
                dragPointIndex = -1;
                
                createBtn.classList.add('active');
                editBtn.classList.remove('active');
                canvasContainer.classList.remove('edit-mode');
                
                const sideText = coatedSideRight ? 'Side B Colored' : 'Side A Colored';
                document.getElementById('mode').textContent = `Create Mode - ${sideText}: Click on canvas to add points`;
                
                closeEditPopup();
                redrawProfile();
                
            } else if (mode === 'edit') {
                if (points.length < 2) {
                    alert('Need at least 2 points to enter edit mode.');
                    setMode('create');
                    return;
                }
                
                isEditMode = true;
                isDrawing = false;
                
                createBtn.classList.remove('active');
                editBtn.classList.add('active');
                canvasContainer.classList.add('edit-mode');
                
                const sideText = coatedSideRight ? 'Side B Colored' : 'Side A Colored';
                document.getElementById('mode').textContent = `Edit Mode - ${sideText}: Click measurements to edit, drag vertices to move`;
                
                redrawProfile();
            }
        }

        function finishProfile() {
            if (points.length < 2) {
                alert('Need at least 2 points to finish the profile.');
                return;
            }
            
            isDrawing = false;
            document.getElementById('mode').textContent = 'Profile finished. Use Edit mode to make changes.';
            // Clear hem vertex index when finishing profile
            window.hemVertexIndex = undefined;
            drawMeasurements();
            updateStats();
            clearPreviewLine();
        }

        function redrawProfile() {
            pointsGroup.innerHTML = '';
            linesGroup.innerHTML = '';
            
            points.forEach((point, index) => {
                drawPoint(point, index);
            });
            
            for (let i = 0; i < points.length - 1; i++) {
                drawLine(points[i], points[i + 1], i);
            }
            
            drawMeasurements();
            updateStats(); // Ensure material usage updates after any change
        }

        function drawHem(pointIndex, hemType) {
            // Remove all Hem logic from drawHem
        }

        function clearCanvas() {
            points = [];
            pointsGroup.innerHTML = '';
            linesGroup.innerHTML = '';
            labelsGroup.innerHTML = '';
            isDrawing = true;
            isEditMode = false;
            isDragging = false;
            dragPointIndex = -1;
            // Clear hem vertex index when starting a new profile
            window.hemVertexIndex = undefined;
            setMode('create');
            
            closeEditPopup();
            
            document.getElementById('profileName').value = '';
            document.getElementById('profileDescription').value = '';
            document.getElementById('mode').textContent = 'Click on the canvas to start drawing your profile';
            updateStats();
            clearPreviewLine();
        }

        function updateStats() {
            let totalLength = 0;
            for (let i = 0; i < points.length - 1; i++) {
                const current = points[i];
                const next = points[i + 1];
                const deltaX = (next.x - current.x) / scale;
                const deltaY = (current.y - next.y) / scale;
                totalLength += Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            }
            
            document.getElementById('totalLength').textContent = `${totalLength.toFixed(3)}"`;
        }

        function applyLengthEditByIndex(lineIndex, newLength) {
            const startPoint = points[lineIndex];
            const endPoint = points[lineIndex + 1];
            
            const deltaX = endPoint.x - startPoint.x;
            const deltaY = endPoint.y - startPoint.y;
            const currentLength = Math.sqrt(deltaX * deltaX + deltaY * deltaY) / scale;
            
            if (currentLength === 0) return;
            
            const ratio = (newLength * scale) / (currentLength * scale);
            const newEndPoint = {
                x: startPoint.x + deltaX * ratio,
                y: startPoint.y + deltaY * ratio
            };
            
            // Temporarily update the point and check for line crossing
            const oldEndPoint = { ...points[lineIndex + 1] };
            points[lineIndex + 1] = { ...endPoint, x: newEndPoint.x, y: newEndPoint.y };
            // Check for line crossing
            for (let i = 0; i < points.length - 2; i++) {
                if (i === lineIndex - 1 || i === lineIndex || i === lineIndex + 1) continue; // skip adjacent lines
                const lineA = { start: points[i], end: points[i + 1] };
                const newLine = { start: points[lineIndex], end: points[lineIndex + 1] };
                if (doLinesIntersect(lineA.start, lineA.end, newLine.start, newLine.end)) {
                    points[lineIndex + 1] = oldEndPoint;
                    showLineCrossPopup();
                    return;
                }
            }
        }

        function applyAngleEditByIndex(vertexIndex, newAngle) {
            const actualVertexIndex = vertexIndex + 1;
            const maxVertices = Math.max(0, points.length - 2);
            if (maxVertices === 0 || actualVertexIndex >= points.length - 1) return;

            const currentPoint = points[actualVertexIndex];
            const prevPoint = points[actualVertexIndex - 1];
            const nextPoint = points[actualVertexIndex + 1];

            const deltaX = nextPoint.x - currentPoint.x;
            const deltaY = nextPoint.y - currentPoint.y;
            const lineLength = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            const prevAngle = Math.atan2(prevPoint.y - currentPoint.y, prevPoint.x - currentPoint.x);
            // Set the angle directly to newAngle (relative to previous segment)
            const newAngleRad = prevAngle + (newAngle * Math.PI / 180);

            // Calculate new coordinates for the next point
            const newX = currentPoint.x + Math.cos(newAngleRad) * lineLength;
            const newY = currentPoint.y + Math.sin(newAngleRad) * lineLength;
            // Temporarily update the point and check for line crossing
            const oldNextPoint = { ...points[actualVertexIndex + 1] };
            points[actualVertexIndex + 1] = { ...points[actualVertexIndex + 1], x: newX, y: newY };
            // Check for line crossing
            for (let i = 0; i < points.length - 2; i++) {
                if (i === actualVertexIndex - 1 || i === actualVertexIndex || i === actualVertexIndex + 1) continue; // skip adjacent lines
                const lineA = { start: points[i], end: points[i + 1] };
                const newLine = { start: points[actualVertexIndex], end: points[actualVertexIndex + 1] };
                if (doLinesIntersect(lineA.start, lineA.end, newLine.start, newLine.end)) {
                    points[actualVertexIndex + 1] = oldNextPoint;
                    showLineCrossPopup();
                    return;
                }
            }
        }

        // Initialize canvas size
        function resizeCanvas() {
            const container = document.querySelector('.canvas-container');
            canvas.setAttribute('width', container.clientWidth);
            canvas.setAttribute('height', container.clientHeight);
        }

        // Close popup when clicking outside
        document.addEventListener('click', function(e) {
            const editPopup = document.getElementById('editPopup');
            
            if (editPopup.style.display === 'block' && !editPopup.contains(e.target)) {
                closeEditPopup();
            }
        });

        // Handle Enter key in popup input
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.getElementById('editPopup').style.display === 'block') {
                applyPopupEdit();
            }
            if (e.key === 'Escape' && document.getElementById('editPopup').style.display === 'block') {
                closeEditPopup();
            }
        });

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function showLineCrossPopup() {
            let popup = document.getElementById('lineCrossPopup');
            if (!popup) {
                popup = document.createElement('div');
                popup.id = 'lineCrossPopup';
                popup.style.position = 'fixed';
                popup.style.left = '50%';
                popup.style.top = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                popup.style.background = 'white';
                popup.style.border = '2px solid #e74c3c';
                popup.style.borderRadius = '10px';
                popup.style.padding = '24px';
                popup.style.zIndex = '3000';
                popup.style.boxShadow = '0 10px 30px rgba(0,0,0,0.3)';
                popup.innerHTML = `
                    <h3 style="color:#e74c3c;margin-bottom:12px;">Invalid Action</h3>
                    <div style="margin-bottom:16px;">Lines cannot cross. Please adjust your profile.</div>
                    <button class="btn btn-danger" onclick="closeLineCrossPopup()">Close</button>
                `;
                document.body.appendChild(popup);
            } else {
                popup.style.display = 'block';
            }
        }

        function closeLineCrossPopup() {
            const popup = document.getElementById('lineCrossPopup');
            if (popup) popup.style.display = 'none';
        }
    </script>
</body>
</html>