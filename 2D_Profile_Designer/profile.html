<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kynetic Metalworks - 2D Profile Designer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #8b8b8b;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: #57626b;
            color: white;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            min-height: 48px;
        }

        .header-text {
            flex: 1;
            text-align: center;
        }

        .header h1 {
            font-size: 1.5em;
            margin-bottom: 2px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1em;
            opacity: 0.8;
        }

        .top-controls {
            background: #f8f9fa;
            padding: 20px 30px;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            gap: 30px;
            align-items: center;
            flex-wrap: nowrap;
            min-width: 0;
        }

        .profile-info {
            flex: 1 1 auto;
            min-width: 0;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .input-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 0;
        }

        .input-field label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 14px;
        }

        .input-field input {
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .input-field input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.2);
        }

        .side-indicator {
            display: flex;
            align-items: center;
            margin-right: 20px;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            color: #2c3e50;
            cursor: pointer;
        }

        .side-toggle {
            position: relative;
            width: 80px;
            height: 32px;
            background: #e9ecef;
            border-radius: 16px;
            overflow: hidden;
            border: 2px solid #ddd;
        }

        .side-toggle input[type="checkbox"] {
            display: none;
        }

        .toggle-slider {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
        }

        .toggle-slider::before {
            content: '';
            position: absolute;
            width: 50%;
            height: 100%;
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            border-radius: 14px;
            transition: all 0.3s ease;
            transform: translateX(0);
            z-index: 1;
        }

        .side-toggle input:checked + .toggle-slider::before {
            transform: translateX(100%);
            background: linear-gradient(135deg, #3498db, #2980b9);
        }

        .side-label {
            position: absolute;
            width: 50%;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
            z-index: 2;
            transition: all 0.3s ease;
        }

        .side-label.left {
            left: 0;
        }

        .side-label.right {
            right: 0;
        }

        .side-toggle input:not(:checked) + .toggle-slider .side-label.left {
            color: white;
        }

        .side-toggle input:not(:checked) + .toggle-slider .side-label.right {
            color: #666;
        }

        .side-toggle input:checked + .toggle-slider .side-label.left {
            color: #666;
        }

        .side-toggle input:checked + .toggle-slider .side-label.right {
            color: white;
        }

        .mode-controls {
            flex-shrink: 0;
            display: flex;
            gap: 15px;
            align-items: center;
            min-width: 0;
        }

        .mode-toggle {
            display: flex;
            background: #e9ecef;
            border-radius: 8px;
            overflow: hidden;
        }

        .mode-btn {
            padding: 10px 20px;
            border: none;
            background: transparent;
            color: #6c757d;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: #3498db;
            color: white;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #2980b9, #1f6591);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #229954, #1e8449);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #c0392b, #a93226);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }

        .main-content {
            height: calc(100vh - 300px);
            min-height: 500px;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            background: #ffffff;
            overflow: hidden;
        }

        .canvas-container.edit-mode #canvas {
            cursor: default;
        }

        #canvas {
            cursor: crosshair;
            background: 
                radial-gradient(circle, #e8e8e8 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .measurement-label {
            fill: #3498db;
            font-size: 12px;
            font-weight: bold;
            font-family: 'Segoe UI', sans-serif;
            pointer-events: none;
            user-select: none;
            transition: all 0.3s ease;
        }

        .angle-label {
            fill: #e67e22;
            font-size: 12px;
            font-weight: bold;
            font-family: 'Segoe UI', sans-serif;
            pointer-events: none;
            user-select: none;
            transition: all 0.3s ease;
        }

        .edit-mode .measurement-label,
        .edit-mode .angle-label {
            pointer-events: all;
            cursor: pointer;
        }

        .edit-mode .measurement-label:hover {
            fill: #e74c3c;
            font-size: 14px;
        }

        .edit-mode .angle-label:hover {
            fill: #9b59b6;
            font-size: 14px;
        }

        .clickable-bg {
            fill: rgba(255, 255, 255, 0.8);
            stroke: rgba(52, 152, 219, 0.5);
            stroke-width: 1;
            rx: 3;
            ry: 3;
            pointer-events: all;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .edit-mode .clickable-bg {
            opacity: 1;
        }

        .edit-mode .clickable-bg:hover {
            fill: rgba(52, 152, 219, 0.1);
            stroke: rgba(52, 152, 219, 0.8);
            stroke-width: 2;
        }

        .angle-arc {
            stroke: #f39c12;
            stroke-width: 1;
            fill: none;
            stroke-dasharray: 3,3;
            opacity: 0.8;
        }

        .edit-popup {
            position: absolute;
            background: white;
            border: 2px solid #3498db;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 1000;
            min-width: 250px;
            display: none;
        }

        .edit-popup h4 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 16px;
        }

        .edit-popup .input-group {
            margin-bottom: 15px;
        }

        .edit-popup .input-group label {
            display: block;
            margin-bottom: 5px;
            color: #2c3e50;
            font-weight: 600;
        }

        .edit-popup .input-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
        }

        .edit-popup .btn {
            width: 48%;
            margin-right: 4%;
        }

        .edit-popup .btn:last-child {
            margin-right: 0;
        }

        .point {
            fill: #3498db;
            stroke: white;
            stroke-width: 2;
            cursor: pointer;
        }

        .point:hover {
            fill: #2980b9;
            stroke-width: 3;
        }

        .point.draggable {
            cursor: grab;
            stroke-width: 3;
            r: 8;
        }

        .point.dragging {
            cursor: grabbing;
            fill: #e74c3c;
            stroke-width: 4;
        }

        .line {
            stroke: #b0b4b9;
            stroke-width: 3;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .preview-line {
            stroke: #95a5a6;
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 5,5;
        }

        .hem-curve {
            stroke: #ff6b35;
            stroke-width: 3;
            fill: none;
            stroke-linecap: round;
        }

        .hem-parallel {
            stroke: #ff6b35;
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 3,3;
            opacity: 0.8;
        }

        .coating-hash {
            stroke: #e74c3c;
            stroke-width: 1;
            stroke-linecap: round;
            opacity: 0.8;
        }

        .status {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: #2c3e50;
            color: white;
            padding: 10px 20px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
        }

        .coords {
            font-family: monospace;
        }

        @media (max-width: 768px) {
            .top-controls {
                flex-direction: column;
                align-items: stretch;
                flex-wrap: wrap;
            }
            
            .profile-info {
                flex-direction: column;
            }
        }

        /* Line Cross Popup */
        #lineCrossPopup {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #e74c3c;
            border-radius: 10px;
            padding: 24px;
            z-index: 3000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: none;
        }

        #lineCrossPopup h3 {
            color: #e74c3c;
            margin-bottom: 12px;
        }

        #lineCrossPopup .btn {
            width: 100%;
            margin-top: 12px;
        }

        /* New styles for resizable description box */
        .input-field input#profileDescription {
            min-height: 48px;
            height: 48px;
            font-size: 15px;
            padding: 10px 12px;
            resize: vertical;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-text">
                <h1>2D Profile Designer</h1>
                <p>Precision Metal Forming Solutions</p>
            </div>
        </div>
        
        <div class="top-controls">
            <div class="profile-info">
                <div class="input-field">
                    <label for="profileName">Profile Name</label>
                    <input type="text" id="profileName" placeholder="Enter profile name">
                </div>
                <div class="input-field">
                    <label for="profileDescription">Description</label>
                    <input type="text" id="profileDescription" placeholder="Enter description">
                </div>
                <div class="input-field">
                    <label>Total Material Usage</label>
                    <div style="padding: 8px 12px; background: #e9ecef; border-radius: 6px; font-weight: bold; color: #2d5a5c;">
                        <span id="totalLength">0.00"</span>
                    </div>
                </div>
            </div>
            
            <div class="mode-controls">
                <div class="side-indicator" style="flex-direction:column; align-items:flex-start;">
                    <label class="toggle-label" style="margin-bottom:0;">
                        <span>Colored Side:</span>
                        <div class="side-toggle">
                            <input type="checkbox" id="sideToggle" onchange="toggleCoatedSide()">
                            <div class="toggle-slider">
                                <span class="side-label left">A</span>
                                <span class="side-label right">B</span>
                            </div>
                        </div>
                    </label>
                    <div id="hashSideInfo" style="margin-top:8px; padding:6px 14px; background:#f3f6fa; border-radius:6px; font-size:14px; color:#3498db; font-weight:500; text-align:center; box-shadow:0 2px 6px rgba(52,152,219,0.07); width:max-content;">
                        Hash side = Color side
                    </div>
                </div>
                <div class="mode-toggle">
                    <button class="mode-btn active" onclick="setMode('create')" id="createModeBtn">Create</button>
                    <button class="mode-btn" onclick="setMode('edit')" id="editModeBtn">Edit</button>
                </div>

                <button class="btn btn-success" onclick="finishProfile()">Finish Profile</button>
                <button class="btn btn-primary" onclick="downloadProfileImage()">Download Image</button>
                <button class="btn btn-danger" onclick="clearCanvas()">Clear All</button>
            </div>
        </div>
        
        <div class="main-content">
            <div class="canvas-container" id="canvasContainer">
                <svg id="canvas" width="100%" height="100%">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                                refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#4a7c7e" />
                        </marker>
                    </defs>
                    <g id="grid"></g>
                    <g id="lines"></g>
                    <g id="points"></g>
                    <g id="labels"></g>
                </svg>
                
                <!-- Edit Popup -->
                <div id="editPopup" class="edit-popup">
                    <h4 id="popupTitle">Edit Element</h4>
                    <div class="input-group">
                        <label id="popupLabel">Value:</label>
                        <input type="number" id="popupInput" step="0.125" placeholder="Enter value">
                    </div>
                    <div>
                        <button class="btn btn-primary" onclick="applyPopupEdit()">Apply</button>
                        <button class="btn btn-danger" onclick="closeEditPopup()">Cancel</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="status">
            <span id="mode">Click on the canvas to start drawing your profile</span>
            <span class="coords" id="coordinates">Mouse: (0, 0)</span>
        </div>
    </div>

    <script>
        function downloadProfileImage() {
            const svg = document.getElementById('canvas');
            const serializer = new XMLSerializer();
            let source = serializer.serializeToString(svg);
            // Add name space
            if(!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)){
                source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
            }
            // Convert SVG to image
            const svgBlob = new Blob([source], {type: 'image/svg+xml;charset=utf-8'});
            const url = URL.createObjectURL(svgBlob);
            const img = new Image();
            img.onload = function() {
                const canvasEl = document.createElement('canvas');
                canvasEl.width = svg.clientWidth;
                canvasEl.height = svg.clientHeight;
                const ctx = canvasEl.getContext('2d');
                ctx.drawImage(img, 0, 0);
                URL.revokeObjectURL(url);
                canvasEl.toBlob(function(blob) {
                    const a = document.createElement('a');
                    a.download = 'profile.png';
                    a.href = URL.createObjectURL(blob);
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }, 'image/png');
            };
            img.src = url;
        }
        let isDrawing = true; // Auto-start drawing
        let isEditMode = false;
        let isDragging = false;
        let dragPointIndex = -1;
        let currentEditElement = null;
        let coatedSideRight = false; // false = left/top coated, true = right/bottom coated
        let points = [];
        let scale = 20; // pixels per inch
        let offset = { x: 50, y: 50 };

        const canvas = document.getElementById('canvas');
        const pointsGroup = document.getElementById('points');
        const linesGroup = document.getElementById('lines');
        const labelsGroup = document.getElementById('labels');

        function closeEditPopup() {
            const popup = document.getElementById('editPopup');
            popup.style.display = 'none';
            currentEditElement = null;
        }

        function applyPopupEdit() {
            if (!currentEditElement) return;
            
            const input = document.getElementById('popupInput');
            const newValue = parseFloat(input.value);
            
            if (isNaN(newValue)) {
                alert('Please enter a valid number.');
                return;
            }
            
            if (currentEditElement.type === 'length') {
                applyLengthEditByIndex(currentEditElement.index, newValue);
            } else if (currentEditElement.type === 'angle') {
                applyAngleEditByIndex(currentEditElement.index, newValue);
            }
            
            redrawProfile();
            updateStats();
            closeEditPopup();
        }

        // Canvas event listeners
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Convert to inches
            const inchX = ((x - offset.x) / scale).toFixed(2);
            const inchY = (((canvas.clientHeight - y) - offset.y) / scale).toFixed(2);
            
            document.getElementById('coordinates').textContent = `Mouse: (${inchX}", ${inchY}")`;
            
            // Handle dragging in edit mode
            if (isDragging && dragPointIndex >= 0) {
                // Preserve custom properties like isHem
                points[dragPointIndex] = { ...points[dragPointIndex], x: x, y: y };
                redrawProfile();
                return;
            }
            
            // Show preview line when drawing
            if (isDrawing && points.length > 0 && !isEditMode) {
                showPreviewLine(x, y);
            }
        }

        function handleMouseDown(e) {
            if (!isEditMode) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if clicking on a point
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                if (distance <= 12) {
                    isDragging = true;
                    dragPointIndex = i;
                    closeEditPopup();
                    
                    const pointElement = document.querySelector(`circle[data-index="${i}"]`);
                    if (pointElement) {
                        pointElement.classList.add('dragging');
                    }
                    break;
                }
            }
        }

        function handleMouseUp(e) {
            if (isDragging) {
                isDragging = false;
                
                const allPoints = document.querySelectorAll('.point');
                allPoints.forEach(point => point.classList.remove('dragging'));
                
                dragPointIndex = -1;
                redrawProfile();
            }
        }

        function handleCanvasClick(e) {
            if (isDragging) return;
            if (isEditMode) return;
            if (!isDrawing) return;
            // Only block clicks on interactive elements (points, labels, popups)
            const ignoreTags = ['circle', 'rect', 'text', 'foreignObject'];
            if (ignoreTags.includes(e.target.tagName)) return;
            // Accept clicks anywhere inside the SVG
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            addPoint(x, y);
        }


        function addPoint(x, y) {
            const point = { x: x, y: y };
            // Prevent line crossing
            if (points.length > 1) {
                const newLine = { start: points[points.length - 1], end: point };
                for (let i = 0; i < points.length - 2; i++) {
                    const lineA = { start: points[i], end: points[i + 1] };
                    if (doLinesIntersect(lineA.start, lineA.end, newLine.start, newLine.end)) {
                        showLineCrossPopup();
                        return;
                    }
                }
            }
            points.push(point);
            drawPoint(point, points.length - 1);
            if (points.length > 1) {
                drawLine(points[points.length - 2], point, points.length - 2);
                clearPreviewLine(); // Remove preview line and label immediately
                drawMeasurements(); // Draw permanent label
                // Remove preview angle label immediately
                const angleLabel = document.getElementById('preview-angle-label');
                if (angleLabel) angleLabel.remove();
            }
            updateStats();
            clearPreviewLine();
        }

        // Helper function to check if two line segments intersect
        function doLinesIntersect(p1, p2, p3, p4) {
            function ccw(a, b, c) {
                return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);
            }
            return (ccw(p1, p3, p4) !== ccw(p2, p3, p4)) && (ccw(p1, p2, p3) !== ccw(p1, p2, p4));
        }

        // Remove all Hem logic from showHemPopup
        function showHemPopup(pointIndex) {
            // No Hem popup logic
        }

        function closeHemPopup() {
            const hemPopup = document.getElementById('hemPopup');
            if (hemPopup) hemPopup.style.display = 'none';
        }

        function applyHemPopup(pointIndex) {
            closeHemPopup();
            redrawProfile();
        }

        // Update drawHem to use new parameters
        function drawHem(pointIndex, hemType, hemLength, openAmount) {
            // No Hem drawing logic
        }

        function drawPoint(point, index) {
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', point.x);
            circle.setAttribute('cy', point.y);
            circle.setAttribute('r', isEditMode ? 8 : 6);
            circle.setAttribute('class', isEditMode ? 'point draggable' : 'point');
            circle.setAttribute('data-index', index);
            pointsGroup.appendChild(circle);
        }

        function drawLine(start, end, index) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', start.x);
            line.setAttribute('y1', start.y);
            line.setAttribute('x2', end.x);
            line.setAttribute('y2', end.y);
            line.setAttribute('class', 'line');
            line.setAttribute('data-index', index);
            linesGroup.appendChild(line);
            
            // Add coating hash marks
            drawCoatingHashes(start, end);
        }

        function drawCoatingHashes(start, end) {
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length < 20) return;
            
            const dirX = dx / length;
            const dirY = dy / length;
            
            const perpX = -dirY;
            const perpY = dirX;
            
            const hashOffset = coatedSideRight ? 8 : -8;
            const offsetX = perpX * hashOffset;
            const offsetY = perpY * hashOffset;
            
            const hashSpacing = 15;
            const hashLength = 6;
            const numHashes = Math.floor(length / hashSpacing);
            
            for (let i = 1; i < numHashes; i++) {
                const t = i / numHashes;
                const lineX = start.x + dx * t;
                const lineY = start.y + dy * t;
                
                const hash1X = lineX + offsetX - perpX * hashLength/2;
                const hash1Y = lineY + offsetY - perpY * hashLength/2;
                const hash2X = lineX + offsetX + perpX * hashLength/2;
                const hash2Y = lineY + offsetY + perpY * hashLength/2;
                
                const hash = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hash.setAttribute('x1', hash1X);
                hash.setAttribute('y1', hash1Y);
                hash.setAttribute('x2', hash2X);
                hash.setAttribute('y2', hash2Y);
                hash.setAttribute('class', 'coating-hash');
                linesGroup.appendChild(hash);
            }
        }

        function showPreviewLine(mouseX, mouseY) {
            clearPreviewLine();
            if (points.length === 0) return;
            const lastPoint = points[points.length - 1];
            // Draw preview (phantom) line
            let previewLine = document.getElementById('preview');
            if (!previewLine) {
                previewLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                previewLine.setAttribute('id', 'preview');
                previewLine.setAttribute('class', 'preview-line');
                linesGroup.appendChild(previewLine);
            }
            previewLine.setAttribute('x1', lastPoint.x);
            previewLine.setAttribute('y1', lastPoint.y);
            previewLine.setAttribute('x2', mouseX);
            previewLine.setAttribute('y2', mouseY);

            // Calculate preview length
            const deltaX = (mouseX - lastPoint.x) / scale;
            const deltaY = (lastPoint.y - mouseY) / scale;
            const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            // Move label off the line, above it in white space
            const midX = (lastPoint.x + mouseX) / 2; // 12px left of center
            const midY = (lastPoint.y + mouseY) / 2 - 24; // 24px above the line

            // Add or update preview length label
            let lengthLabel = document.getElementById('preview-length-label');
            if (!lengthLabel) {
                lengthLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                lengthLabel.setAttribute('id', 'preview-length-label');
                lengthLabel.setAttribute('class', 'measurement-label');
                lengthLabel.setAttribute('text-anchor', 'middle');
                lengthLabel.setAttribute('dominant-baseline', 'central');

                linesGroup.appendChild(lengthLabel);
            }
            lengthLabel.setAttribute('x', midX);
            lengthLabel.setAttribute('y', midY);
            lengthLabel.textContent = `${length.toFixed(3)}"`;

            // Calculate preview angle
            if (points.length > 1) {
                const prev = points[points.length - 2];
                const last = points[points.length - 1];
                const mousePt = { x: mouseX, y: mouseY };
                const vec1 = { x: prev.x - last.x, y: prev.y - last.y };
                const vec2 = { x: mousePt.x - last.x, y: mousePt.y - last.y };
                const dot = vec1.x * vec2.x + vec1.y * vec2.y;
                const mag1 = Math.sqrt(vec1.x * vec1.x + vec1.y * vec1.y);
                const mag2 = Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
                let angle = 0;
                if (mag1 > 0 && mag2 > 0) {
                    angle = Math.acos(dot / (mag1 * mag2)) * 180 / Math.PI;
                }
                // Place angle label at the previous vertex, above it
                let angleLabel = document.getElementById('preview-angle-label');
                if (!angleLabel) {
                    angleLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    angleLabel.setAttribute('id', 'preview-angle-label');
                    angleLabel.setAttribute('class', 'angle-label');
                    angleLabel.setAttribute('text-anchor', 'middle');
                    angleLabel.setAttribute('dominant-baseline', 'central');
                    linesGroup.appendChild(angleLabel);
                }
                angleLabel.setAttribute('x', last.x);
                angleLabel.setAttribute('y', last.y - 44); // 44px above vertex
                angleLabel.textContent = `${angle.toFixed(1)}°`;
            } else {
                // Remove angle label if not needed
                const angleLabel = document.getElementById('preview-angle-label');
                if (angleLabel) angleLabel.remove();
            }
        }

        function clearPreviewLine() {
            const preview = document.getElementById('preview');
            if (preview) {
                preview.remove();
            }
        }

        function drawMeasurements() {
            labelsGroup.innerHTML = '';
            const lineCount = points.length - 1;
            for (let i = 0; i < lineCount; i++) {
                const current = points[i];
                const next = points[i + 1];
                const deltaX = (next.x - current.x) / scale;
                const deltaY = (current.y - next.y) / scale;
                const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                // Move permanent label off the line, above it in white space
                const midX = (current.x + next.x) / 2;
                const midY = (current.y + next.y) / 2 - 24;
                createClickableLabel(midX, midY, `${length.toFixed(3)}"`, 'measurement-label', 'length', i);
            }
            
            // Draw angle measurements for interior vertices
            for (let i = 1; i < points.length - 1; i++) {
                const current = points[i];
                const prev = points[i - 1];
                const next = points[i + 1];
                const angle = calculateVertexAngle(i);
                createClickableLabel(current.x + 25, current.y - 25, `${angle.toFixed(1)}°`, 'angle-label', 'angle', i - 1);
                drawAngleArc(prev, current, next, angle);
            }
        }

        function createClickableLabel(x, y, text, className, type, index) {
            // Create background rectangle for better clicking
            const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            const textWidth = text.length * 8;
            bg.setAttribute('x', x - textWidth/2 - 4);
            bg.setAttribute('y', y - 8);
            bg.setAttribute('width', textWidth + 8);
            bg.setAttribute('height', 16);
            bg.setAttribute('class', 'clickable-bg');
            bg.setAttribute('data-type', type);
            bg.setAttribute('data-index', index);
            
            // Create text element
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', x);
            label.setAttribute('y', y);
            label.setAttribute('class', className);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('dominant-baseline', 'central');
            label.setAttribute('data-type', type);
            label.setAttribute('data-index', index);
            label.textContent = text;
            
            // Add click handlers to both elements
            const clickHandler = function(e) {
                if (!isEditMode) return;
                e.stopPropagation();
                e.preventDefault();
                showEditPopup(e, type, index, text);
            };
            
            bg.addEventListener('click', clickHandler);
            label.addEventListener('click', clickHandler);
            
            labelsGroup.appendChild(bg);
            labelsGroup.appendChild(label);
        }

        function showEditPopup(event, type, index, currentValue) {
            const popup = document.getElementById('editPopup');
            const title = document.getElementById('popupTitle');
            const label = document.getElementById('popupLabel');
            const input = document.getElementById('popupInput');
            
            currentEditElement = { type: type, index: index };
            
            if (type === 'length') {
                title.textContent = `Edit Line ${index + 1} Length`;
                label.textContent = 'Length (inches):';
                input.value = parseFloat(currentValue.replace('"', '')).toFixed(3);
            } else {
                title.textContent = `Edit Vertex ${index + 1} Angle`;
                label.textContent = 'Angle (degrees):';
                input.value = parseFloat(currentValue.replace('°', '')).toFixed(1);
            }
            
            // Get the position of the clicked element
            const targetElement = event.target;
            const canvasRect = canvas.getBoundingClientRect();
            
            let elementX, elementY;
            
            if (targetElement.tagName === 'text') {
                elementX = parseFloat(targetElement.getAttribute('x'));
                elementY = parseFloat(targetElement.getAttribute('y'));
            } else if (targetElement.tagName === 'rect') {
                const rectX = parseFloat(targetElement.getAttribute('x'));
                const rectY = parseFloat(targetElement.getAttribute('y'));
                const rectWidth = parseFloat(targetElement.getAttribute('width'));
                const rectHeight = parseFloat(targetElement.getAttribute('height'));
                elementX = rectX + rectWidth / 2;
                elementY = rectY + rectHeight / 2;
            }
            
            const pageX = canvasRect.left + elementX;
            const pageY = canvasRect.top + elementY;
            
            popup.style.left = (pageX + 30) + 'px';
            popup.style.top = (pageY - 25) + 'px';
            
            popup.style.display = 'block';
            const popupRect = popup.getBoundingClientRect();
            
            if (popupRect.right > window.innerWidth) {
                popup.style.left = (pageX - popupRect.width - 30) + 'px';
            }
            
            if (popupRect.bottom > window.innerHeight) {
                popup.style.top = (pageY - popupRect.height - 10) + 'px';
            }
            
            if (popupRect.top < 0) {
                popup.style.top = (pageY + 30) + 'px';
            }
            
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
        }

        function drawAngleArc(prevPoint, centerPoint, nextPoint, angle) {
            const vec1 = { x: prevPoint.x - centerPoint.x, y: prevPoint.y - centerPoint.y };
            const vec2 = { x: nextPoint.x - centerPoint.x, y: nextPoint.y - centerPoint.y };
            
            const angle1 = Math.atan2(vec1.y, vec1.x);
            const angle2 = Math.atan2(vec2.y, vec2.x);
            
            let startAngle = angle1;
            let endAngle = angle2;
            
            let angleDiff = endAngle - startAngle;
            if (angleDiff > Math.PI) {
                angleDiff -= 2 * Math.PI;
            } else if (angleDiff < -Math.PI) {
                angleDiff += 2 * Math.PI;
            }
            
            if (Math.abs(angleDiff) > Math.PI) {
                [startAngle, endAngle] = [endAngle, startAngle];
                angleDiff = endAngle - startAngle;
                if (angleDiff > Math.PI) {
                    angleDiff -= 2 * Math.PI;
                } else if (angleDiff < -Math.PI) {
                    angleDiff += 2 * Math.PI;
                }
            }
            
            const radius = 20;
            
            const startX = centerPoint.x + radius * Math.cos(startAngle);
            const startY = centerPoint.y + radius * Math.sin(startAngle);
            const endX = centerPoint.x + radius * Math.cos(endAngle);
            const endY = centerPoint.y + radius * Math.sin(endAngle);
            
            const largeArcFlag = Math.abs(angleDiff) > Math.PI ? 1 : 0;
            const sweepFlag = angleDiff > 0 ? 1 : 0;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const pathData = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`;
            path.setAttribute('d', pathData);
            path.setAttribute('class', 'angle-arc');
            
            labelsGroup.appendChild(path);
        }

        function calculateVertexAngle(vertexIndex) {
            const current = points[vertexIndex];
            const prev = points[vertexIndex - 1];
            const next = points[vertexIndex + 1];
            
            const vec1 = { x: prev.x - current.x, y: prev.y - current.y };
            const vec2 = { x: next.x - current.x, y: next.y - current.y };
            
            const dot = vec1.x * vec2.x + vec1.y * vec2.y;
            const mag1 = Math.sqrt(vec1.x * vec1.x + vec1.y * vec1.y);
            const mag2 = Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
            
            let angle = Math.acos(dot / (mag1 * mag2)) * 180 / Math.PI;
            return angle;
        }

        function toggleCoatedSide() {
            coatedSideRight = document.getElementById('sideToggle').checked;
            redrawProfile();
            
            const sideText = coatedSideRight ? 'Side B Colored' : 'Side A Colored';
            const currentMode = isEditMode ? 'Edit Mode' : 'Create Mode';
            document.getElementById('mode').textContent = `${currentMode} - ${sideText}`;
        }

        function setMode(mode) {
            const createBtn = document.getElementById('createModeBtn');
            const editBtn = document.getElementById('editModeBtn');
            const canvasContainer = document.getElementById('canvasContainer');
            
            if (mode === 'create') {
                isEditMode = false;
                isDrawing = true;
                isDragging = false;
                dragPointIndex = -1;
                
                createBtn.classList.add('active');
                editBtn.classList.remove('active');
                canvasContainer.classList.remove('edit-mode');
                
                const sideText = coatedSideRight ? 'Side B Colored' : 'Side A Colored';
                document.getElementById('mode').textContent = `Create Mode - ${sideText}: Click on canvas to add points`;
                
                closeEditPopup();
                redrawProfile();
                
            } else if (mode === 'edit') {
                if (points.length < 2) {
                    alert('Need at least 2 points to enter edit mode.');
                    setMode('create');
                    return;
                }
                
                isEditMode = true;
                isDrawing = false;
                
                createBtn.classList.remove('active');
                editBtn.classList.add('active');
                canvasContainer.classList.add('edit-mode');
                
                const sideText = coatedSideRight ? 'Side B Colored' : 'Side A Colored';
                document.getElementById('mode').textContent = `Edit Mode - ${sideText}: Click measurements to edit, drag vertices to move`;
                
                redrawProfile();
            }
        }

        function finishProfile() {
            if (points.length < 2) {
                alert('Need at least 2 points to finish the profile.');
                return;
            }
            
            isDrawing = false;
            document.getElementById('mode').textContent = 'Profile finished. Use Edit mode to make changes.';
            drawMeasurements();
            updateStats();
            clearPreviewLine();
        }

        function redrawProfile() {
            pointsGroup.innerHTML = '';
            linesGroup.innerHTML = '';
            
            points.forEach((point, index) => {
                drawPoint(point, index);
            });
            
            for (let i = 0; i < points.length - 1; i++) {
                drawLine(points[i], points[i + 1], i);
            }
            
            drawMeasurements();
        }

        function drawHem(pointIndex, hemType) {
            // Remove all Hem logic from drawHem
        }

        function clearCanvas() {
            points = [];
            pointsGroup.innerHTML = '';
            linesGroup.innerHTML = '';
            labelsGroup.innerHTML = '';
            isDrawing = true;
            isEditMode = false;
            isDragging = false;
            dragPointIndex = -1;
            
            setMode('create');
            
            closeEditPopup();
            
            document.getElementById('profileName').value = '';
            document.getElementById('profileDescription').value = '';
            document.getElementById('mode').textContent = 'Click on the canvas to start drawing your profile';
            updateStats();
            clearPreviewLine();
        }

        function updateStats() {
            let totalLength = 0;
            for (let i = 0; i < points.length - 1; i++) {
                const current = points[i];
                const next = points[i + 1];
                const deltaX = (next.x - current.x) / scale;
                const deltaY = (current.y - next.y) / scale;
                totalLength += Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            }
            
            document.getElementById('totalLength').textContent = `${totalLength.toFixed(3)}"`;
        }

        function applyLengthEditByIndex(lineIndex, newLength) {
            const startPoint = points[lineIndex];
            const endPoint = points[lineIndex + 1];
            
            const deltaX = endPoint.x - startPoint.x;
            const deltaY = endPoint.y - startPoint.y;
            const currentLength = Math.sqrt(deltaX * deltaX + deltaY * deltaY) / scale;
            
            if (currentLength === 0) return;
            
            const ratio = (newLength * scale) / (currentLength * scale);
            const newEndPoint = {
                x: startPoint.x + deltaX * ratio,
                y: startPoint.y + deltaY * ratio
            };
            
            points[lineIndex + 1] = { ...endPoint, x: newEndPoint.x, y: newEndPoint.y };
        }

        function applyAngleEditByIndex(vertexIndex, newAngle) {
            const actualVertexIndex = vertexIndex + 1;
            const maxVertices = Math.max(0, points.length - 2);
            if (maxVertices === 0 || actualVertexIndex >= points.length - 1) return;

            const currentPoint = points[actualVertexIndex];
            const prevPoint = points[actualVertexIndex - 1];
            const nextPoint = points[actualVertexIndex + 1];

            const deltaX = nextPoint.x - currentPoint.x;
            const deltaY = nextPoint.y - currentPoint.y;
            const lineLength = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            const prevAngle = Math.atan2(prevPoint.y - currentPoint.y, prevPoint.x - currentPoint.x);
            const newAngleRad = prevAngle + Math.PI - (newAngle * Math.PI / 180);

            // Calculate new coordinates for the next point
            const newX = currentPoint.x + Math.cos(newAngleRad) * lineLength;
            const newY = currentPoint.y + Math.sin(newAngleRad) * lineLength;
            points[actualVertexIndex + 1] = { ...points[actualVertexIndex + 1], x: newX, y: newY };
        }

        // Initialize canvas size
        function resizeCanvas() {
            const container = document.querySelector('.canvas-container');
            canvas.setAttribute('width', container.clientWidth);
            canvas.setAttribute('height', container.clientHeight);
        }

        // Close popup when clicking outside
        document.addEventListener('click', function(e) {
            const editPopup = document.getElementById('editPopup');
            
            if (editPopup.style.display === 'block' && !editPopup.contains(e.target)) {
                closeEditPopup();
            }
        });

        // Handle Enter key in popup input
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.getElementById('editPopup').style.display === 'block') {
                applyPopupEdit();
            }
            if (e.key === 'Escape' && document.getElementById('editPopup').style.display === 'block') {
                closeEditPopup();
            }
        });

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function showLineCrossPopup() {
            let popup = document.getElementById('lineCrossPopup');
            if (!popup) {
                popup = document.createElement('div');
                popup.id = 'lineCrossPopup';
                popup.style.position = 'fixed';
                popup.style.left = '50%';
                popup.style.top = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                popup.style.background = 'white';
                popup.style.border = '2px solid #e74c3c';
                popup.style.borderRadius = '10px';
                popup.style.padding = '24px';
                popup.style.zIndex = '3000';
                popup.style.boxShadow = '0 10px 30px rgba(0,0,0,0.3)';
                popup.innerHTML = `
                    <h3 style="color:#e74c3c;margin-bottom:12px;">Invalid Action</h3>
                    <div style="margin-bottom:16px;">Lines cannot cross. Please adjust your profile.</div>
                    <button class="btn btn-danger" onclick="closeLineCrossPopup()">Close</button>
                `;
                document.body.appendChild(popup);
            } else {
                popup.style.display = 'block';
            }
        }

        function closeLineCrossPopup() {
            const popup = document.getElementById('lineCrossPopup');
            if (popup) popup.style.display = 'none';
        }
    </script>
</body>
</html>